/**
 *  Copyright (c) 1999-2010, Ecole des Mines de Nantes
 *  All rights reserved.
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *      * Neither the name of the Ecole des Mines de Nantes nor the
 *        names of its contributors may be used to endorse or promote products
 *        derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package samples;

import choco.Choco;
import choco.Options;
import choco.cp.model.CPModel;
import choco.cp.solver.CPSolver;
import choco.cp.solver.search.integer.valselector.MaxVal;
import choco.cp.solver.search.integer.varselector.StaticVarOrder;
import choco.kernel.common.util.comparator.IPermutation;
import choco.kernel.common.util.tools.ArrayUtils;
import choco.kernel.common.util.tools.MathUtils;
import choco.kernel.common.util.tools.PermutationUtils;
import choco.kernel.model.Model;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;
import choco.kernel.model.variables.integer.IntegerVariable;
import choco.kernel.solver.variables.integer.IntDomainVar;
import org.kohsuke.args4j.Option;
import samples.tutorials.PatternExample;

import java.util.Random;
import java.util.logging.Level;

/**
 * Assume that a product is to be shipped in the amounts u1, ... , um, from each of m shipping origins, and received in amounts v1, ... , vn, by each of n shipping destinations.
 * The problem consists of determining the amounts xij, to be shipped from origins i to destinations j, to minimize the cost of transportation.
 *
 * @author Arnaud Malapert</br>
 * @version 2.1.1</br>
 * @since 7 oct. 2009 version 2.1.1</br>
 */
public class Transportation extends PatternExample {


    public final static int MAX_DEMAND_OR_STOCK = 10;


    protected Random rnd;

    @Option(name = "-n", usage = "Number of origins (default: 13)", required = false)
    /** number of origins */
    public int n = 13;

    /**
     * Amount of product available at the origins.
     */
    public int[] stocks;

    @Option(name = "-m", usage = "Number of destinations (default: 3)", required = false)
    /** number of destinations */
    public int m = 3;


    @Option(name = "-seed", usage = "Seed for random", required = false)
    /** number of destinations */
    public long seed = System.currentTimeMillis();


    /**
     * Amount of products received by each destination.
     */
    public int[] demands;

    /**
     * total amount of products available at the origin or  received by the destination
     */
    public int totalStockOrDemand;

    /**
     * Transportation cost from the origin i to the destination j
     */
    public int[][] costs;

    public IntegerVariable[][] shipping;

    public IntegerVariable objective;

    public Transportation() {
    }

    public void prepare() {
        rnd = new Random(seed);
        //stocks and demands are generated by randomly solving a CP problem
        Model model = new CPModel();
        IntegerVariable[] d = Choco.makeIntVarArray("d", m, 1, MAX_DEMAND_OR_STOCK);
        IntegerVariable[] s = Choco.makeIntVarArray("d", n, 1, MAX_DEMAND_OR_STOCK);
        IntegerVariable t = Choco.makeIntVar("total", 0, Math.min(m, n) * MAX_DEMAND_OR_STOCK);
        model.addConstraints(
                Choco.eq(Choco.sum(d), t),
                Choco.eq(Choco.sum(s), t)
        );
        CPSolver solver = new CPSolver();
        solver.read(model);
        solver.setRandomSelectors(rnd.nextInt(100));
        solver.solve();
        stocks = new int[n];
        for (int i = 0; i < n; i++) {
            stocks[i] = solver.getVar(s[i]).getVal();
        }
        demands = new int[m];
        for (int i = 0; i < m; i++) {
            demands[i] = solver.getVar(d[i]).getVal();
        }
        totalStockOrDemand = solver.getVar(t).getVal();
        //costs
        costs = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                costs[i][j] = rnd.nextInt(15) + 1;
            }
        }
    }


    @Override
    public void buildModel() {
        prepare();
        model = new CPModel();
        shipping = Choco.makeIntVarArray("s", n, m, 0, MathUtils.max(stocks), Options.V_BOUND);
        for (int i = 0; i < n; i++) {
            //The total amount shipped from origin i must be equals to the sum of amount going from it to all destinations
            model.addConstraint(Choco.eq(Choco.sum(shipping[i]), stocks[i]));
        }
        for (int i = 0; i < m; i++) {
            //The total amount received at destination i must be equals to the sum of amount shipped to it from all origins.
            model.addConstraint(Choco.eq(Choco.sum(ArrayUtils.getColumn(shipping, i)), demands[i]));
        }
        //objective function
        objective = Choco.makeIntVar("total_cost", 0, MathUtils.max(costs) * totalStockOrDemand, Options.V_OBJECTIVE,
                Options.V_BOUND, Options.V_NO_DECISION);
        IntegerExpressionVariable objExp = Choco.constant(0);
        for (int i = 0; i < n; i++) {
            objExp = Choco.plus(objExp, Choco.scalar(shipping[i], costs[i]));
        }
        model.addConstraint(Choco.eq(objective, objExp));
    }

    @Override
    public void buildSolver() {
        CPSolver solver = new CPSolver();
        solver = solver;
        solver.read(model);
        //System.out.println(solver.pretty());
        //Naive Search Strategy: sort the variables shipping_ij accroding to their increasing costs
        //Select shipping with minimal cost and assign its maximal value
        final IntDomainVar[] dvars = solver.getIntDecisionVars();
        final IntDomainVar[] sdvars = new IntDomainVar[dvars.length];
        final IPermutation permutation = PermutationUtils.getSortingPermuation(ArrayUtils.flatten(costs));
        permutation.applyPermutation(dvars, sdvars);
        solver.setVarIntSelector(new StaticVarOrder(solver, sdvars));
        solver.setValIntSelector(new MaxVal());
    }

    @Override
    public void prettyOut() {
        if (LOGGER.isLoggable(Level.INFO)) {
            StringBuilder b = new StringBuilder(32);
            for (int i = 0; i < shipping.length; i++) {
                for (int j = 0; j < shipping[i].length; j++) {
                    final int v = solver.getVar(shipping[i][j]).getVal();
                    if (v > 0) {
                        b.append(i).append(" -> ").append(j);
                        b.append(": ").append(v).append('\n');
                    }
                }
            }
            LOGGER.info(new String(b));
        }
    }

    @Override
    public void solve() {
        solver.minimize(false);

    }

    public static void main(String[] args) {
        new Transportation().execute(args);
    }

}
