/**
 *  Copyright (c) 1999-2010, Ecole des Mines de Nantes
 *  All rights reserved.
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *      * Neither the name of the Ecole des Mines de Nantes nor the
 *        names of its contributors may be used to endorse or promote products
 *        derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package choco.cp.solver.constraints.global.tree.filtering.structuralFiltering.globalCardConstraint;

import choco.cp.solver.constraints.global.tree.filtering.RemovalsAdvisor;
import choco.cp.solver.constraints.global.tree.structure.internalStructure.graphStructures.graphViews.VarGraphView;
import choco.kernel.solver.ContradictionException;
import choco.kernel.solver.Solver;




public class GlobalCardinalityNoLoop extends AbstractBipartFlow {

    /**
     * boolean for debug and show a trace of the execution
     */
    protected boolean affiche;

    /**
     * data structure related to the graph representation of the input graph
     */
    protected VarGraphView inputGraph;

    /**
     * Constructor: build a global cardinality constraint API, short cut when smallest value equals 0
     *
     * @param solver  the choco problem involving the constraint
     * @param pack  a set of parameters : treeParams, indices, struct, affiche
     */
    public GlobalCardinalityNoLoop(Solver solver, Object[] pack) {
        super(solver, pack);
        this.affiche = (Boolean)pack[2];
        this.minValue = 0;
        this.maxValue = nbLeftVertices; // valeur de l'etat boucle est le nbre de variables peres
        for (int i = 0; i < this.minFlow.length; i++) {
            this.minFlow[i] = struct.getDegree().getLow()[i];
            this.maxFlow[i] = struct.getDegree().getUp()[i];
        }
        this.inputGraph = struct.getInputGraph();
    }

    public void deleteEdgeAndPublish(int i, int j, RemovalsAdvisor rem) {
        deleteMatch(i, j);
        // update the associated bipartite graph
        this.graph[i].set(j + minValue, false);
        // apply removals
        int val = j + minValue;
        if (val >= graph.length) {
            if (inputGraph.getGlobal().getSuccessors(i).get(val)) {
                if (affiche) {
                    LOGGER.info("\t"+solver.getEnvironment().getWorldIndex()+" --> 1-GCC: suppression de l'arc (" + index[i] + "," + val + ")");
                }
                int[] arc = {index[i], val};
                rem.addRemoval(arc);
            }
        } else {
            if (inputGraph.getGlobal().getSuccessors(index[i]).get(val)) {
                if (affiche) {
                    LOGGER.info("\t"+solver.getEnvironment().getWorldIndex()+" --> 2-GCC: suppression de l'arc (" + index[i] + "," + val + ")");
                }
                int[] arc = {index[i], val};
                rem.addRemoval(arc);
            }
        }
    }

    /**
     * Achieves generalized arc consistency in one call
     * <p/>
     * remove arcs connecting two different strongly connected components
     * the event generated by the flow algorithm:
     * discovering that an edge is no longer valid, and posting this event
     * to the constraint solver: since we are already achieving GAC consistency
     * in one single loop.
     * @param rem
     * @return
     * @throws choco.kernel.solver.ContradictionException
     */
    public boolean applyGCC(RemovalsAdvisor rem) throws ContradictionException {
        for (int i = 0; i < nbRightVertices; i++) {
            int nbUsed = 0;
            for (int j = 0; j < nbLeftVertices; j++) {
                if (graph[j].get(i)) nbUsed++;
            }
            if ((nbUsed < minFlow[i]) || !struct.getDegree().isCompatibleDegree()) {
                if (affiche) LOGGER.info("nbUsed = " + nbUsed + " VS minFlow[" + i + "] = " + minFlow[i] + " ==> ECHEC");
                return false;
            }
        }
        propagate(rem);
        return isFeasible;
    }
}
