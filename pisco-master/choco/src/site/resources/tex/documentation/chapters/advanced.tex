%!TEX root = ../content-doc.tex
%\part{advanced}
\label{advanced}
\hypertarget{advanced}{}


\chapter{Advanced uses of Choco}\label{advanced:advancedusesofchoco}\hypertarget{advanced:advancedusesofchoco}{}

\section{Environment}\label{advanced:environment}\hypertarget{advanced:environment}{}

Environment is a central object of the backtracking system. It defines the notion of \textit{world}. A world contains values of storable objects or operations that permit to \textit{backtrack} to its state. The environment \textit{pushes} and \textit{pops} worlds.

There are \textit{primitive} data types (\mylst{IStateBitSet, IStateBool, IStateDouble, IStateInt, IStateLong}) and \textit{objects} data types (\mylst{IStateBinarytree, IStateIntInterval, IStateIntProcedure, IStateIntVector, IStateObject, IStateVector}).

There are two different environments: \textit{EnvironmentTrailing} and \textit{EnvironmentCopying}.

\subsection{Copying}\label{advanced:copying}\hypertarget{advanced:copying}{}
In that environment, each data type is defined by a value (primitive or object) and a timestamp. Every time a world is pushed, each value is copied in an array (one array per data type), with finite indice. When a world is popped, every value is restored. 

\subsection{Trailing}\label{advanced:trailing}\hypertarget{advanced:trailing}{}
In that environment, data types are defined by its value. Every operation applied to a data type is pushed in a \textit{trailer}. When a world is pushed, the indice of the last operation is stored. When a world is popped, these operations are popped and \textit{unapplied} until reaching the last operation of the previous world.\\\textit{Default one in CPSolver}

\subsection{Backtrackable structures}\label{advanced:backtrackablestructures}\hypertarget{advanced:backtrackablestructures}{}
\todo{to complete}
\section{How does the propagation engine work ?}

Once the \mylst{Model} and \mylst{Solver} have been defined, the resolution can start. It is based on decisions and filtering orders, this is the propagation engine. In this part, we're going to present how the resolution is guided in Choco. 

A resolution instruction (\mylst{solve()}, \mylst{solveAll()}, \mylst{maximize(...)} or \mylst{minimize(...)}) always starts by setting options based on resolution policy, then generates the search strategies and ends by running the search loop. 

\subsection{How does a search loop work ?}\label{advanced:howdoesasearchloopwork}\hypertarget{advanced:howdoesasearchloopwork}{}
The search loop is the \textit{conductor} of the engine. It goes down and up in the branches in order to cover the tree search, call the filtering algorithm, etc.
Here is the organigram of the search loop. 

%\insertGraphique{0.8\linewidth}{media/searchloop.pdf}{Organigram of the search loop}

\begin{figure}[!htp]
	\centerline{\Graph{media/searchloop.pdf}{width=1\linewidth}}
	\caption[]{Organigram of the search loop}\label{fig:media/searchloop.pdf}
\end{figure}

Basically, the search loop is divided in 5 steps: \mylst{INITIAL PROPAGATION} (highlighted in red), \mylst{OPEN NODE} (highlighted in green), \mylst{DOWN BRANCH} (highlighted in violet), \mylst{UP BRANCH} (highlighted in orange) and \mylst{RESTART} (highlighted in blue). 

\subsection{Propagate}\label{advanced:propagate}\hypertarget{advanced:propagate}{}

%% fix point A fix point is reached when there is no more event to treat
\newglossaryentry{fix point}{name={fix point},description={definition of a fix point}}

The main and unique \mylst{PropagationEngine} of Choco is \mylst{ChocoEngine}. This engine stores events occurring on variables, \textit{variable events}, and specific calls to constraint filtering algorithm, \textit{constraint events}, in order to reach a \gls{fix point} or to detect contradictions. Events are stored in queues (FIFO).  

On a call to \mylst{Solver.propagate()} or during a resolution step, the consistency of a model is computed: stored events are popped and propagated (apply side-effects). The propagation of a single event can create new ones, feeding the system until fix point or contradiction. 



\begin{figure}[!htp]
	\centerline{\Graph{media/propagationloop.pdf}{width=0.5\linewidth}}
	\caption[]{Organigram of the propagation loop}\label{fig:media/propagationloop.pdf}
\end{figure}

 
If the propagation of an event leads to a contradiction, the propagation engine stop the process. In both case, the search loop take up with the new state.

\subsubsection{Seven priorities}

Before going further, it is important to know that events declare a parameter named \textit{priority}. The priority of a constraint's event depends on the constraint priority (required in the super class constructor). And the priority of a variable's event is given by the maximum priority of the variable's constraints. 

To each priority corresponds a \textit{rank}. In the propagation engine, there are as many queues as ranks. 
During the propagation loop, the rank is used to push the event on the corresponding queue. Events are \underline{always} popped from the smallest ranked queue to the largest ranked queue.

There are seven priorities :  \mylst{UNARY}, \mylst{BINARY}, \mylst{TERNARY}, \mylst{LINEAR}, \mylst{QUADRATIC}, \mylst{CUBIC} and \mylst{VERY_SLOW}, each of these qualifies the "cost" of a constraint (related to its internal filtering algorithm). 

By default, priorities and ranks are defined as follow:
\begin{tabular}{|l|r|}
\hline
Priority & Rank \\
\hline
unary & 1\\
binary & 2\\
ternary & 3\\
linear & 4\\
quadratic & 5\\
cubic & 6\\
very slow & 7\\
\hline
\end{tabular}
\vspace{0.2cm}

Although the priority of a constraint cannot be changed, the rank of priority can be reconsider by setting another value to \mylst{Configuration.VEQ_ORDER} or \mylst{Configuration.CEQ_ORDER}. 

\vspace{0.5cm}

\begin{lstlisting}
Configuration conf = new Configuration();
conf.putInt(Configuration.VEQ_ORDER, 7654321); // default value is 1234567
conf.putInt(Configuration.CEQ_ORDER, 1111744); // default value is 1234567
Solver solver = new CPSolver(conf);
\end{lstlisting}

In that example, priorities ranks are reversed for the variable queues, and totally rearranged for the constraint queue.


\subsubsection{Constraint event}

At the very beginning of resolution, when constraint filtering algorithms have not been called once, a call to the \mylst{awake()} method is planned by posting constraint event to the propagation engine. For some \textit{expensive} constraints (like \hyperlink{geost:geostconstraint}{Geost}), a call to the main filtering algorithm (described in \mylst{propagate()}) can be added during the resolution by posting a constraint event to the propagation engine, in that case a call to the \mylst{propagate()} method is planned. 
This event is added to the list of constraint events to be treated by the propagation engine.

\subsubsection{Variable event}

The resolution goal is to instantiate variables in order to find solutions. Instantiation of a variable is done applying modification on its domain. 
Each time a modification is applied on a domain, an event is posted, storing informations about the action done (event type, variable, values, etc.). This event will be given to the related constraints of the modified variable, to check consistency and propagate this new information to the other variables.

Depending on the type of domain, events existing in Choco are:

\noindent\begin{tabular}{lp{.6\linewidth}}
\hline
Event &  description \\
\hline
\multicolumn{2}{l}{Integer variable \mylst{IntDomainVar}}\\
  \hline
  \mylst{REMVAL} & Remove a single value from the domain.\\
  \mylst{INCINF} &  Increase the lower bound of the domain. \\
  \mylst{DECSUP} &  Decrease the upper bound of the domain. \\
  \mylst{INSTINT} &  Instantiate the domain, i.e. reduce it to a single value. \\   
\hline
\multicolumn{2}{l}{Set variable \mylst{SetVar}}\\
\hline
  \mylst{REMENV} & Remove a single value from the envelope domain \\
  \mylst{ADDKER} &  Add a single value to the kernel domain\\
  \mylst{INSTSET} &  Instantiate the domain, i.e. set values to both kernel and envelope domain. \\   
\hline  
\multicolumn{2}{l}{Real variable \mylst{RealVar}}\\
\hline
  \mylst{INCINF} &  Increase the lower bound of the domain\\
  \mylst{DECSUP} &  Decrease the upper bound of the domain\\
\hline  
\end{tabular}

An event given as a parameter to the engine is then pushed into a unique queue, waiting to be treated. There are seven different queues where an event can be pushed, it depends on the priority of the event.
   

Beware, an event is not automatically pushed in a queue: if an other event based on the same variable is already present in the queue, the two events are merged into one. 
\begin{note}
Due to promotion, variables' events can be treated in a different order than creation one!

Let X and Y, two integer variables with priorities of the same rank. During the propagation of a constraint, the lower bound of a integer variable X is updated to 3 (this event is added to the queue Q), then Y is instantiated to 4 (this other event is added to the same queue Q) and finally the upper bound of X is updated to 4 (the already pushed event on X is updated with this new information). At that point, there are only 2 events in the queue Q: one on X and one on Y. 
As X and Y have the same rank, events will be treated by creation order: event on X first ant event on Y then. But the event on X contains 2 informations, one on the lower bound modification and another on the upper bound modification. So, although the instantiation of Y has been created first, the treatment of the upper bound modification of X will be treated first.
\end{note}


\begin{note}
Original event can be \textit{promoted}: for example removing the last but one value of an integer variable is promoted to instantiation.

Promotion are:

\noindent\begin{tabular}{lp{.6\linewidth}}
\hline
Original event &  can be promoted to \\
\hline
\multicolumn{2}{l}{Integer variable \mylst{IntDomainVar}}\\
  \hline
  \mylst{REMVAL} & \mylst{INCINF} or \mylst{DECSUP} or \mylst{INSTINT}\\
  \mylst{INCINF} &  \mylst{INSTINT}\\
  \mylst{DECSUP} &  \mylst{INSTINT} \\
  \mylst{INSTINT} &  \textit{none} \\   
\hline
\multicolumn{2}{l}{Set variable \mylst{SetVar}}\\
\hline
  \mylst{REMENV} & \mylst{INSTSET} \\
  \mylst{ADDKER} &  \mylst{INSTSET}\\
  \mylst{INSTSET} &  \textit{none} \\   
\hline  
\multicolumn{2}{l}{Real variable \mylst{RealVar}}\\
\hline
  \mylst{INCINF} &  \textit{none}\\
  \mylst{DECSUP} &  \textit{none}\\
\hline  
\end{tabular}

 \end{note}


\section{Define your own search strategy}\label{advanced:defineyourownsearchstrategy}\hypertarget{advanced:defineyourownsearchstrategy}{}
%A key ingredient of any constraint approach is a clever branching strategy. The construction of the search tree is done according to a series of Branching objects (that plays the role of achieving intermediate goals in logic programming). The user may specify the sequence of branching objects to be used to build the search tree. 
Section~\hyperlink{solver:searchstrategy}{Search strategy} presented the default branching strategies available in Choco and showed how to post them or to compose them as goals.
In this section, we will start with a very simple and common way to branch by choosing values for variables and specially how to define its own variable/value selection strategy. We will then focus on more complex branching such as dichotomic or n-ary choices. Finally we will show how to control the search space in more details with well known strategy such as LDS (Limited discrepancy search).

Reminder : \hyperlink{advanced:howdoesasearchloopwork}{How does the search loop work?}

For integer variables, the variable and value selection strategy objects are based on the following interfaces:
\begin{itemize}
	\item \mylst{AbstractIntBranchingStrategy}: abstract class for the branching strategy,
	\item \mylst{VarSelector<V>} : Interface for the variable selection (\mylst{V extends Var}),
	\item \mylst{ValIterator<V>} : Interface to describes an iteration scheme on the domain of a variable,
	\item \mylst{ValSelector<V>} : Interface for a value selection.
\end{itemize}

Concrete examples of these interfaces are respectively,  \hyperlink{assignvar:assignvarbranchstrat}{AssignVar}, \hyperlink{mindomain:mindomainvarselector}{MinDomain}, \hyperlink{increasingdomain:increasingdomainvaliterator}{IncreasingDomain}, \hyperlink{maxval:maxvalvalselector}{MaxVal}.

\subsection{How to define your own Branching object}\label{advanced:beyondvariable/valueselection,howtodefineyourownbranchingobject}\hypertarget{advanced:beyondvariable/valueselection,howtodefineyourownbranchingobject}{}

When you need a specific branching strategy that can't be expressed with the ones already existing, you can define your own concrete class of:

\noindent{\begin{tabular}{ll}
\hline
  Default class to implement &  definition \\
  \hline
  \mylst{AbstractBinIntBranchingStrategy} &  abstract class defining a binary tree search \\
  \mylst{AbstractLargeIntSConstraint} &  abstract class defining a n-ary tree search. \\
  \hline\\
\end{tabular}}


\insertGraphique{\linewidth}{media/branching.pdf}{Branching strategy: interfaces and abstract classes.}

We give here two examples of implementations of these classes, first for a binary branching, then for a n-ary branching. 
\begin{lstlisting}   
/**
 * A class for branching schemes that consider two branches: 
 * - one assigning a value to an IntVar (X == v) 
 * - and the other forbidding this assignment (X != v)
 */
public class AssignOrForbid extends AbstractBinIntBranchingStrategy {

    protected VarSelector<IntDomainVar> varSelector;

    protected ValSelector<IntDomainVar> valSelector;

    public AssignOrForbid(VarSelector<IntDomainVar> varSelector,
                          ValSelector<IntDomainVar> valSelector) {
        super();
        this.valSelector = valSelector;
        this.varSelector = varSelector;
    }

    /**
     * Select the variable to constrained
     *
     * @return the branching object
     */
    public Object selectBranchingObject() throws ContradictionException {
        return varSelector.selectVar();
    }

    /**
     * Select the value to assign, and set it in the decision object in parameter
     * @param decision the next decision to apply
     */
    @Override
    public void setFirstBranch(final IntBranchingDecision decision) {
        decision.setBranchingValue(valSelector.getBestVal(decision.getBranchingIntVar()));
    }


    /**
     * Create and return the message to print, in case of strong verbosity
     * @param decision current decision
     * @return pretty print of the current decision
     */
    @Override
    public String getDecisionLogMessage(final IntBranchingDecision decision) {
        return decision.getBranchingObject() +  (decision.getBranchIndex() == 0 ? "==" : "=/=") + decision.getBranchingValue();
    }


    /**
     * Execution action based on the couple: {decision, branching index}.
     * As <code>this</code> build a binary branching, there are only 2 branching indices:
     * 0 -- assignment, the variable is instantiated to the value
     * 1 -- forbidance, the value is removed from the domain of the variable
     *
     * @throws ContradictionException if the decision leads to an incoherence
     */
    @Override
    public void goDownBranch(final IntBranchingDecision decision) throws ContradictionException {
        if (decision.getBranchIndex() == 0) {
            decision.setIntVal();
        } else {
            decision.remIntVal();
        }
    }
}
\end{lstlisting}

\begin{lstlisting}   
/**
 * A class for branching schemes that consider n branches: 
 * -  assigning a value v_i to an variable (X == v_i)
 */
public class Assign extends AbstractLargeIntBranchingStrategy {

    protected final VarSelector<IntDomainVar> varSelector;

    protected ValIterator<IntDomainVar> valIterator;

    public Assign(VarSelector<IntDomainVar> varSelector, ValIterator<IntDomainVar> valIterator) {
        this.varSelector = varSelector;
        this.valIterator = valIterator;
    }

    /**
     * Select the variable to constrained
     *
     * @return the branching object
     */
    public Object selectBranchingObject() throws ContradictionException {
        return varSelector.selectVar();
    }

    /**
     * Select the first value to assign, and set it in the decision object in parameter
     *
     * @param decision the first decision to apply
     */
    public void setFirstBranch(final IntBranchingDecision decision) {
        decision.setBranchingValue(valIterator.getFirstVal(decision.getBranchingIntVar()));
    }

    /**
     * Select the next value to assign, and set it in the decision object in parameter
     *
     * @param decision the next decision to apply
     */
    public void setNextBranch(final IntBranchingDecision decision) {
        decision.setBranchingValue(valIterator.getNextVal(decision.getBranchingIntVar(), decision.getBranchingValue()));
    }

    /**
     * Check wether there is still a value to assign
     *
     * @param decision the last decision applied
     * @return <code>false</code> if there is still a branching to do
     */
    public boolean finishedBranching(final IntBranchingDecision decision) {
        return !valIterator.hasNextVal(decision.getBranchingIntVar(), decision.getBranchingValue());
    }

    /**
     * Apply the computed decision building the i^th branch.
     * --> assignment: the variable is instantiated to the value
     * 
     * 
     * @param decision the decision to apply.
     * @throws ContradictionException if the decision leads to an incoherence
     */
    @Override
    public void goDownBranch(final IntBranchingDecision decision) throws ContradictionException {
        decision.setIntVal();
    }

    /**
     * Reconsider the computed decision, destroying the i^th branch
     * --> forbiddance: the value is removed from the domain of the variable
     * 
     * @param decision the decision that has been set at the father choice point
     * @throws ContradictionException if the non-decision leads to an incoherence
     */
    @Override
    public void goUpBranch(final IntBranchingDecision decision) throws ContradictionException {
        decision.remIntVal();
    }

    /**
     * Create and return the message to print, in case of strong verbosity
     * @param decision current decision
     * @return pretty print of the current decision
     */
    @Override
    public String getDecisionLogMessage(IntBranchingDecision decision) {
        return decision.getBranchingObject() + "==" + decision.getBranchingValue();
    }
}
\end{lstlisting}

\subsection{Define your own variable selection}\label{advanced:defineyourownvariableselection}\hypertarget{advanced:defineyourownvariableselection}{}

\insertGraphique{.5\linewidth}{media/varselector-s.pdf}{Variable selector: interface}

You may extend this small library of branching schemes and heuristics by defining your own concrete classes of \mylst{AbstractIntVarSelector}. We give here an example of an \mylst{VarSelector<IntDomainVar>} with the implementation of a static variable ordering :
\begin{lstlisting}
/**
 * A variable selector selecting the first non instantiated variable according to a given static order
 */
public class StaticVarOrder extends AbstractIntVarSelector {

    private final IStateInt last;

    public StaticVarOrder(Solver solver) {
        super(solver);
        this.last = solver.getEnvironment().makeInt(0);
    }

    public StaticVarOrder(Solver solver, IntDomainVar[] vars) {
        super(solver, vars);
        this.last = solver.getEnvironment().makeInt(0);
    }

    /**
     * Select the next uninstantiated variable, according to the define policy: input order
     * @return the selected variable if exists, <code>null</code> otherwise
     */
    public IntDomainVar selectVar() {
        for (int i = last.get(); i < vars.length; i++) {
            if (!vars[i].isInstantiated()) {
                last.set(i);
                return vars[i];

            }
        }
        return null;
    }
}
\end{lstlisting}

Notice on this example that you only need to implement method \mylst{selectVar()} which belongs to the contract of \mylst{VarSelector}. This method should return a non instantiated variable or \mylst{null}. Once the branching is finished, the next branching (if one exists) is taken by the search algorithm to continue the search, otherwise, the search stops as all variable are instantiated. To avoid the loop over the variables of the branching, a backtrackable integer (\mylst{IStateInt}) could be used to remember the last instantiated variable and to directly select the next one in the table. Notice that backtrackable structures could be used in any of the code presented in this chapter to speedup the computation of dynamic choices.

\insertGraphique{.8\linewidth}{media/varselector-a.pdf}{Variable selector: interface and abstract classes}

If you need an integer variable selector that can be used as a parameter of \hyperlink{lexintvarselector:lexintvarselectorvarselector}{LexIntVarSelector}, it should extend \mylst{IntHeuristicIntVarSelector} or \mylst{DoubleHeuristicIntVarSelector}. These two abstract classes only require to implement one method : \mylst{getHeuristic(IntDomainVar v)} which computes and returns a criterion (\mylst{int} or \mylst{double}). The criteria are used in a master class to select the smallest crtierion's variable 

We give here an other example of an \mylst{VarSelector<IntDomainVar>}, this one extends \mylst{IntHeuristicIntVarSelector} and choose the variable with the smallest domain :
\begin{lstlisting}
public class MinDomain extends IntHeuristicIntVarSelector {

	public MinDomain(Solver solver) {
		super(solver);
	}

	public MinDomain(Solver solver, IntDomainVar[] vs) {
		super(solver, vs);
	}

    /**
     * Compute the criterion, according to the define policy: smallest domain size
     * @return the selected variable if exists, <code>null</code> otherwise
     */
	@Override
	public int getHeuristic(IntDomainVar v) {
		return v.getDomainSize();
	}

}
\end{lstlisting}


You can add your variable selector as a part of a search strategy, using \mylst{solver.addGoal()}.

\subsection{Define your own value selection}\label{advanced:defineyourownvalueselection}\hypertarget{advanced:defineyourownvalueselection}{}
You may also define your own concrete classes of \mylst{ValIterator} or \mylst{ValSelector}. 

\subsubsection{Value selector}\label{advanced:valueselector}\hypertarget{advanced:valueselector}{}

\insertGraphique{.3\linewidth}{media/valselector.pdf}{Value selector: interface}

We give here an example of an \mylst{IntValSelector} with the implementation of a minimum value selecting:
\begin{lstlisting}
public class MinVal implements ValSelector<IntDomainVar> {
  /**
   * selecting the lowest value in the domain
   *
   * @param x the variable under consideration
   * @return what seems the most interesting value for branching
   */
  public int getBestVal(IntDomainVar x) {
    return x.getInf();
  }
}
\end{lstlisting}
Only \mylst{getBestVal()} method must be implemented, returning the best value \emph{in the domain} according to the heuristic.

You can add your value selector as a part of a search strategy, using \mylst{solver.addGoal()}.

\begin{note}
Using a value selector with bounded domain variable is strongly inadvised, except if it pick up bounds value. If the value selector pick up a value that is not a bound, when it goes up in the tree search, that value could be not removed and picked twice (or more)!
\end{note} 

\subsubsection{Values iterator}\label{advanced:valuesiterator}\hypertarget{advanced:valuesiterator}{}

\insertGraphique{.3\linewidth}{media/valiterator.pdf}{Value iterator: interface}

We give here an example of an \mylst{ValIterator} with the implementation of an increasing domain iterator:
\begin{lstlisting}
public class IncreasingDomain implements ValIterator<IntDomainVar> {

  /**
   * testing whether more branches can be considered after branch i, on the alternative associated to variable x
   *
   * @param x the variable under scrutiny
   * @param i the index of the last branch explored
   * @return true if more branches can be expanded after branch i
   */
  public boolean hasNextVal(IntDomainVar x, int i) {
    return (i < x.getSup());
  }

  /**
   * Accessing the index of the first branch for variable x
   *
   * @param x the variable under scrutiny
   * @return the index of the first branch (such as the first value to be assigned to the variable)
   */
  public int getFirstVal(IntDomainVar x) {
    return x.getInf();
  }

  /**
   * generates the index of the next branch after branch i, on the alternative associated to variable x
   *
   * @param x the variable under scrutiny
   * @param i the index of the last branch explored
   * @return the index of the next branch to be expanded after branch i
   */
  public int getNextVal(IntDomainVar x, int i) {
    return x.getNextDomainValue(i);
  }
}
\end{lstlisting}
%Works as an basic \mylst{Iterator} object, implementing the three main methods \mylst{hasNextVal()}, \mylst{getFirstVal()} and \mylst{getNextVal()}.

You can add your value iterator as a part of a search strategy, using \mylst{solver.addGoal()}.

%\todo{under development} See \href{http://choco-solver.net/index.phptitle=userguide:beyondvariable.2fvalueselection.2chowtodefineyourownbranchingobject}{old version}

\section{Define your own limit search space}\label{advanced:defineyourownlimitsearchspace}\hypertarget{advanced:defineyourownlimitsearchspace}{}

To define your own limits/statistics (notice that a limit object can be used only to get statistics about the search), you can create a limit object by extending the \mylst{AbstractGlobalSearchLimit} class or implementing directly the interface \mylst{IGlobalSearchLimit}. Limits are managed at each node of the tree search and are updated each time a node is open or closed. Notice that limits are therefore time consuming. Implementing its own limit need only to specify to the following interface :

\begin{lstlisting}
	/**
	 * The interface of objects limiting the global search exploration
	 */
	public interface GlobalSearchLimit {

	  /**
	   * resets the limit (the counter run from now on)
	   * @param first true for the very first initialization, false for subsequent ones
	   */
	  public void reset(boolean first);
	
	  /**
	   * notify the limit object whenever a new node is created in the search tree
	   * @param solver the controller of the search exploration, managing the limit
	   * @return true if the limit accepts the creation of the new node, false otherwise
	   */
	  public boolean newNode(AbstractGlobalSearchSolver solver);
	
	  /**
	   * notify the limit object whenever the search closes a node in the search tree
	   * @param solver the controller of the search exploration, managing the limit
	   * @return true if the limit accepts the death of the new node, false otherwise
	   */
	  public boolean endNode(AbstractGlobalSearchSolver solver);
	}
\end{lstlisting}

Look at the following example to see a concrete implementation of the previous interface. We define here a limit on the depth of the search (which is not found by default in choco). The \mylst{getWorldIndex()} is used to get the current world, i.e the current depth of the search or the number of choices which have been done from baseWorld. 

\begin{lstlisting}
	public class DepthLimit extends AbstractGlobalSearchLimit {
	
	  public DepthLimit(AbstractGlobalSearchSolver theSolver, int theLimit) {
	    super(theSolver,theLimit);
	    unit = "deep";
	  }
	
	  public boolean newNode(AbstractGlobalSearchSolver solver) {
	    nb = Math.max(nb, this.getProblem().getWorldIndex() ‚Äì
	    this.getProblem().getSolver().getSearchSolver().baseWorld);
	    return (nb < nbMax);
	  }
	
	  public boolean endNode(AbstractGlobalSearchSolver solver) {
	    return true;
	  }
	
	  public void reset(boolean first) {
	   if (first) {
	    nbTot = 0;
	   } else {
	    nbTot = Math.max(nbTot, nb);
	   }
	   nb = 0;
	  }
\end{lstlisting}

Once you have implemented your own limit, you need to tell the search solver to take it into account. Instead of using a call to the \mylst{solve()} method, you have to create the search solver by yourself and add the limit to its limits list such as in the following code :
\begin{lstlisting}
	Solver s = new CPSolver();
	s.read(model);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.getSearchStrategy().limits.add(new DepthLimit(s.getSearchStrategy(),10));
	s.launch();
\end{lstlisting}

%\subsubsection{Search loop with recomputation}\label{advanced:searchloopwithrecomputation}\hypertarget{advanced:searchloopwithrecomputation}{}

\section{Define your own constraint}\label{advanced:defineyourownconstraint}\hypertarget{advanced:defineyourownconstraint}{}

This section describes how to add you own constraint, with specific propagation algorithms. Note that this section is only useful in case you want to express a constraint for which the basic propagation algorithms (using tables of tuples, or boolean predicates) are not efficient enough to propagate the constraint.

The general process consists in defining a new constraint class and implementing the various propagation methods. We recommend the user to follow the examples of existing constraint classes (for instance, such as \mylst{GreaterOrEqualXYC} for a binary inequality) 

\subsection{The constraint hierarchy}\label{advanced:theconstrainthierarchy}\hypertarget{advanced:theconstrainthierarchy}{}

Each new constraint must be represented by an object implementing the \mylst{SConstraint} interface (\mylst{S} for solver constraint). To help the user defining new constraint classes, several abstract classes defining \texttt{SConstraint} have been implemented. These abstract classes provide the user with a management of the constraint network and the propagation engineering. They should be used as much as possible.

For constraints on integer variables, the easiest way to implement your own constraint is to inherit from one of the following classes, depending of the number of solver integer variables (\texttt{IntDomainVar}) involved:

\centerline{\begin{tabular}{ll}
      \hline
  Default class to implement &  number of solver integer variables \\
  \hline
  \mylst{AbstractUnIntSConstraint} &  \textbf{one} variable \\
  \mylst{AbstractBinIntSConstraint} &  \textbf{two} variables \\
  \mylst{AbstractTernIntSConstraint} &  \textbf{three} variables \\
  \mylst{AbstractLargeIntSConstraint} &  any number of variables. \\
  \hline\\
\end{tabular}}

\noindent Constraints over integers must implement the following methods (grouped in the \texttt{IntSConstraint} interface):

\noindent\begin{tabular}{lp{.6\linewidth}}
  \hline
  Method to implement &  description \\
  \hline
  \mylst{pretty()} &Returns a pretty print of the constraint \\
  \mylst{propagate()} &The main propagation method (propagation from scratch). Propagating the constraint until local consistency is reached. \\
  \mylst{awake()} &Propagating the constraint for the very first time until local consistency is reached. The awake is meant to initialize the data structures contrary to the propagate. Specially, it is important to avoid initializing the data structures in the constructor. \\
  \mylst{awakeOnInst(int x)} &Default propagation on instantiation: full constraint re-propagation. \\
  \mylst{awakeOnBounds(int x)} &Default propagation on improved bounds: propagation on domain revision. \\
  \mylst{awakeOnRemovals(int x, IntIterator v)} &Default propagation on mutliple values removal: propagation on domain revision. The iterator allow to iterate over the values that have been removed. \\
&\\
\hline
\multicolumn{2}{l}{Methods \texttt{awakeOnBounds} and \texttt{awakeOnRemovals} can be replaced by more fine grained methods:}\\
\hline
%Alternative Method &  description \\
%  \hline
  \mylst{awakeOnInf(int x)} &Default propagation on improved lower bound: propagation on domain revision. \\
  \mylst{awakeOnSup(int x)} &Default propagation on improved upper bound: propagation on domain revision. \\
  \mylst{awakeOnRem(int x, int v)} &Default propagation on one value removal: propagation on domain revision.  \\
&\\
  \hline
\multicolumn{2}{l}{To use the constraint in expressions or reification, the following minimum API is mandatory:}\\
  \hline
  \mylst{isSatisfied(int[] x)} &Tests if the constraint is satisfied when the variables are instantiated. \\
	\mylst{isEntailed()} &Checks if the constraint must be checked or must fail. It returns true if the constraint is known to be satisfied whatever happend on the variable from now on, false if it is violated. \\
	\mylst{opposite()} &It returns an AbstractSConstraint that is the opposite of the current constraint. \\
    \hline\\
	\end{tabular}

In the same way, a \textbf{set constraint} can inherit from \texttt{AbstractUnSetSConstraint}, \texttt{AbstractBinSetSConstraint}, \texttt{AbstractTernSetSConstraint} or \texttt{AbstractLargeSetSConstraint}.

A \textbf{real constraint} can inherit from \texttt{AbstractUnRealSConstraint}, \texttt{AbstractBinRealSConstraint} or \texttt{AbstractLargeRealSConstraint}.

A mixed constraint between \textbf{set and integer variables} can inherit from \texttt{AbstractBinSetIntSConstraint} or \texttt{AbstractLargeSetIntSConstraint}.

\begin{note}
A simple way to implement its own constraint is to:
\begin{itemize}
	\item create an empty constraint with only \texttt{propagate()} method implemented and every \texttt{awakeOnXxx()} ones set to \texttt{this.constAwake(false);}
	\item when the propagation filter is sure, separate it into the \texttt{awakeOnXxx()} methods in order to have finer granularity
	\item finally, if necessary, use backtrackables objects to improve the efficient of your constraint
\end{itemize}

\end{note}

\subsubsection{Interact with variables}\label{advanced:interactwithvariables}\hypertarget{advanced:interactwithvariables}{}

One of the constraint function is to remove forbidden values from domain variable (\textit{filtering}). \mylst{Variable}s provide services to allow constraint to interact with their domain.

\vspace{0.5cm}
\textbf{IntDomainVar}

\begin{description}
\item[ ] \mylst{boolean removeVal(int x, final SConstraint cause, final boolean forceAwake)}

Update the domain of the integer variable by removing \mylst{x} from the domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the value has been removed without any trouble, \mylst{false} the value was not present in the domain. A \mylst{ContradictionException} is thrown if it empties the domain of the variable

\item[ ] \mylst{boolean removeInterval(int a, int b, final SConstraint cause, final boolean forceAwake)}

Update the domain of the integer variable by removing all values contained in the interval $[a,b]$ from the domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the values has been removed without any trouble, \mylst{false} if the intersection of the current domain and $[a,b]$ was empty. A \mylst{ContradictionException} is thrown if it empties the domain of the variable.

\item[ ] \mylst{boolean updateInf(int x, final SConstraint cause, final boolean forceAwake)} 

Update the domain of the integer variable by removing all values strictly below \mylst{x} from the domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the lower bound has been updated without any trouble, \mylst{false} the new lower bound was smaller or equal to the actual one. A \mylst{ContradictionException} is thrown if it empties the domain of the variable.

\item[ ] \mylst{boolean updateSup(int x, final SConstraint cause, final boolean forceAwake)} 

Update the domain of the integer variable by removing all values strictly above \mylst{x} from the domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the upper bound has been updated without any trouble, \mylst{false} the new upper bound was greater or equal to the actual one. A \mylst{ContradictionException} is thrown if it empties the domain of the variable. 

\item[ ] \mylst{boolean instantiate(int x, final SConstraint cause, final boolean forceAwake)} 

Update the domain of the integer variable by removing all values but \mylst{x} from the domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the domain has been reduced to a singleton without any trouble, \mylst{false} the domain was already instantiated to the same value . A \mylst{ContradictionException} is thrown if \mylst{x} is out of the domain or if the domain was already instantiated to another value.

\end{description}

\vspace{0.5cm}
\textbf{SetVar}

\begin{description}
\item[ ] \mylst{boolean remFromEnveloppe(int x, final SConstraint cause, final boolean forceAwake)}

Update the domain of the set variable by removing \mylst{x} from the envelope's domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the value has been removed without any trouble, \mylst{false} the value was not present in the envelope. A \mylst{ContradictionException} is thrown if \mylst{x} is present in the kernel's domain.

\item[ ] \mylst{boolean addToKernel(int x, final SConstraint cause, final boolean forceAwake)}

Update the domain of the set variable by adding \mylst{x} into the kernel's domain. \mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the value has been added without any trouble, \mylst{false} the value was already present in the kernel. A \mylst{ContradictionException} is thrown if \mylst{x} is not present in the envelope's domain.

\item[ ] \mylst{boolean instantiate(int[] xs, final SConstraint cause, final boolean forceAwake)} 

Update the domain of the set variable by removing every values but those in \mylst{xs} from the envelope's domain and by adding every values of \mylst{xs} into the kernel's domain. A set variable is known as \textit{instantiated} when $E \cap K \ne \emptyset $ and $E \bigtriangleup K = \emptyset$. 
\mylst{cause} is the constraint at the origin of the event, \mylst{forceAwake} indicates wether or not the \mylst{cause} constraint must be informed of this event. The result of such call can be \mylst{true}, the envelope or the kernel have been updated without trouble, \mylst{false} the envelope and the kernel were already equal to \mylst{xs} . A \mylst{ContradictionException} is thrown if the at least one value from \mylst{xs} is not present in the kernel's domain or in the envelope's domain.
 
\end{description}

\vspace{0.5cm}
\textbf{RealVar}

\begin{description}
\item[ ] \mylst{void intersect(RealInterval interval)}

Update the domain of the real variable by intersecting the domain with \mylst{interval} (define at least by two doubles, known as lower and upper bound). A \mylst{ContradictionException} is thrown the resulting interval is incoherent (the new lower bound is greater than the new upper bound).

\end{description}


\subsubsection{How do I add my constraint to the Model ?}\label{advanced:howdoiaddmyconstrainttothemodel}\hypertarget{advanced:howdoiaddmyconstrainttothemodel}{}

Adding your constraint to the model requires you to definite a specific constraint manager (that can be a inner class of your Constraint).
This manager need to implement:
\begin{lstlisting}
makeConstraint(Solver s, Variable[] vars, Object params, HashSet<String> options)
\end{lstlisting}
This method allows the Solver to create an instance of your constraint, with your parameters and Solver objects.

\begin{note}
If you create your constraint manager as an inner class, you must declare this class as \textbf{public and static}.
If you don't, the solver can't instantiate your manager.
\end{note}

Once this manager has been implemented, you simply add your constraint to the model using the \texttt{addConstraint()} API with a \texttt{ComponentConstraint} object:
\begin{lstlisting}
  model.addConstraint( new ComponentConstraint(MyConstraintManager.class, params, vars) );
  // OR
  model.addConstraint( new ComponentConstraint("package.of.MyConstraint", params, vars) );
\end{lstlisting}
Where \emph{params} is whatever you want (\texttt{Object[], int, String},...) and \emph{vars} is an array of Model Variables (or more specific) objects.

\subsection{Example: implement and add the \texttt{IsOdd} constraint}
One creates the constraint by implementing the \texttt{AbstractUnIntSConstraint} (one integer variable) class:
\lstinputlisting{java/isodd.j2t}

To add the constraint to the model, one creates the following class (or inner class):
\lstinputlisting{java/isoddmanager.j2t}
It calls the constructor of the constraint, with every \emph{vars}, \emph{params} and \emph{options} needed.

Then, the constraint can be added to a model as follows:
\begin{lstlisting}
	// Creation of the model
	Model m = new CPModel();
	
	// Declaration of the variable
	IntegerVariable aVar = Choco.makeIntVar("a_variable", 0, 10);
	
	// Adding the constraint to the model, 1st solution:
	m.addConstraint(new ComponentConstraint(IsOddManager.class, null, new IntegerVariable[]{aVar}));
	// OR 2nd solution:
	m.addConstraint(new ComponentConstraint("myPackage.Constraint.IsOddManager", null, new IntegerVariable[]{aVar}));
	
	Solver s = new CPSolver();
	s.read(m);
	s.solve();
\end{lstlisting}
And that's it!!

\subsection{Example of an empty constraint}\label{advanced:anexempleofemptyconstraint}\hypertarget{advanced:anexempleofemptyconstraint}{}

%See the complete code: \href{media/zip/constraintpattern.zip}{ConstraintPattern.zip}

\begin{lstlisting}
  public class ConstraintPattern extends AbstractLargeIntSConstraint {
      
      public ConstraintPattern(IntDomainVar[] vars) {
          super(vars);
      }
	
      /**
      * pretty print. The String is not constant and may depend on the context.
      * @return a readable string representation of the object
      */
      public String pretty() {
          return null;
      }
	
      /**
      * check whether the tuple satisfies the constraint
      * @param tuple values
      * @return true if satisfied
      */
      public boolean isSatisfied(int[] tuple) {
          return false;
      }

      /**
      * propagate until local consistency is reached
      */
      public void propagate() throws ContradictionException {
          // elementary method to implement
      }
	    
      /**
      * propagate for the very first time until local consistency is reached.
      */
      public void awake() throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
	
      /**
      * default propagation on instantiation: full constraint re-propagation
      * @param var index of the variable to reduce
      */
      public void awakeOnInst(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on improved lower bound: propagation on domain revision
      * @param var index of the variable to reduce
      */
      public void awakeOnInf(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
	
      /**
      * default propagation on improved upper bound: propagation on domain revision
      * @param var index of the variable to reduce
      */
      public void awakeOnSup(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on improve bounds: propagation on domain revision
      * @param var index of the variable to reduce
      */
      public void awakeOnBounds(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on one value removal: propagation on domain revision
      * @param var index of the variable to reduce
      * @param val the removed value
      */
      public void awakeOnRem(int var, int val) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on one value removal: propagation on domain revision
      * @param var index of the variable to reduce
      * @param delta iterator over remove values
      */
      public void awakeOnRemovals(int var, IntIterator delta) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
  }
\end{lstlisting}

The first step to create a constraint in Choco is to implement all \texttt{awakeOn...} methods with \texttt{constAwake(false)} and to put your propagation algorithm in the \texttt{propagate()} method. 

A constraint can choose not to react to fine grained events such as the removal of a value of a given variable but instead delay its propagation at the end of the fix point reached by ``fine grained events'' and fast constraints that deal with them incrementally (that's the purpose of the constraints events queue). 

To do that, you can use \texttt{constAwake(false)} that tells the solver that you want this constraint to be called only once the variables events queue is empty. This is done so that heavy propagators can delay their action after the fast one to avoid doing a heavy processing at each single little modification of domains.

\section{Define your own operator}\label{advanced:defineyourownoperator}\hypertarget{advanced:defineyourownoperator}{}
%\todo{to complete}

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

There are 2 types of operators: \textbf{boolean} and \textbf{arithmetic}. These operators are based on integer variable and/or integer constants. 
Let's take 2 examples \textit{plus} and \textit{eq}.

The operator \textit{plus} is an arithmetic one (see  \mylst{PlusNode.java} class for details) that computes the sum of two variables (and/or constants). It extends  \mylst{INode} (it can be part of an expression object) and implements  \mylst{ArithmNode} (it can be evaluated). So, required services are:

\begin{itemize}
\item a constructor. The type of operator should be defined using \mylst{CUSTOM}.
\begin{lstlisting}
public PlusNode(INode[] subt) {
	super(subt, NodeType.CUSTOM);
}
\end{lstlisting}
\item  \mylst{pretty()} : a pretty print of the operator
\begin{lstlisting}
public String pretty() {
        return "("+subtrees[0].pretty()+" + "+subtrees[1].pretty()+")";
    }
\end{lstlisting}

\item  \mylst{eval(int[] tuple)} : evaluation of the operator with the given tuple. An arithmetic evaluation of the subtrees is done (based on the given tuple) to compute the sub expression before evaluating the current operator \textit{plus}. This allows tree-like representation of an expression.
\begin{lstlisting}
public int eval(int[] tuple) {
		return ((ArithmNode) subtrees[0]).eval(tuple) + ((ArithmNode) subtrees[1]).eval(tuple);
}
\end{lstlisting}
\end{itemize}


The operator \textit{eq} is a boolean one (see  \mylst{EqNode.java} class for more details) that checks if two variables (and/or constants) are equal. It extends  \mylst{AbstractBooleanNode} (that can be checked). So required services are:
\begin{itemize}
\item a constructor
\begin{lstlisting}
public EqNode(INode[] subt) {
        super(subt, NodeType.CUSTOM);
    }
\end{lstlisting}
\item  \mylst{pretty()} : a pretty print of the operator
\begin{lstlisting}
public String pretty() {
        return "("+subtrees[0].pretty()+"="+subtrees[1].pretty()+")";
}
\end{lstlisting} 

\item  \mylst{eval(int[] tuple)}: an expression checker, based on the given tuple. An arithmetic evaluation of the subtrees is done (based on the given tuple) in order to check the operator \textit{eq}.
\begin{lstlisting}
public boolean checkTuple(int[] tuple) {
		return ((ArithmNode) subtrees[0]).eval(tuple)
		        ==  ((ArithmNode) subtrees[1]).eval(tuple);
	}
\end{lstlisting}

\item  \mylst{extractConstraint(Solver s)} : extracts the corresponding constraint in intension constraint without reification.
\begin{lstlisting}
public SConstraint extractConstraint(Solver s) {
        IntDomainVar v1 = subtrees[0].extractResult(s);
		IntDomainVar v2 = subtrees[1].extractResult(s);
		return s.eq(v1,v2);
    }
\end{lstlisting}
\end{itemize}
Now let's see how to use this operator in a Model.

To do that, create your own manager implementing \mylst{ExpressionManager}, which makes the link between the model and the solver.

Then to use your operator in your model, you can define a static method to simplify the calls.

Let's sum up in a short example based on the \textit{plus} operator. 

The manager would be:
\begin{lstlisting}
public class PlusManager implements ExpressionManager {
    @Override
    public INode makeNode(Solver solver, Constraint[] cstrs, Variable[] vars) {
        if(solver instanceof CPSolver){
            CPSolver s = (CPSolver)solver;
            if(vars.length == 1){
                INode[] nodes = new INode[vars.length];
                for(int v = 0; v < vars.length; v++){
                    nodes[v] = vars[v].getExpressionManager().makeNode(s, vars[v].getConstraints(), vars[v].getVariables());
                }
                return new PlusNode(nodes);
            }
        }
        throw new ModelException("Could not found a node manager in " + this.getClass() + " !");
    }
}
\end{lstlisting}


A main class would be:
\begin{lstlisting}
public class Sandbox {

    public static void main(String[] args) {
        model1();
    }

    public static IntegerExpressionVariable plus(IntegerVariable x){
        return new IntegerExpressionVariable(null, "package.of.PlusManager", x);
    }

    private static void model1() {
        Model m = new CPModel();
        IntegerVariable x = Choco.makeIntVar("x", 0, 5);
        IntegerVariable y = Choco.makeIntVar("y", 4, 8);
        IntegerVariable z = Choco.makeIntVar("z", 0, 10);
	
        // declare an expression using my operator
        IntegerExpressionVariable xx = plus(x,y);

        // and use it in common constraint
        m.addConstraint(Choco.eq(z, xx));

        Solver s = new CPSolver();
        s.read(m);

        ChocoLogging.toSolution();
        s.solveAll();
    }
}
\end{lstlisting}

Keep in mind that you can not define operators for set and real. 

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

\section{Define your own variable}\label{advanced:defineyourownvariable}\hypertarget{advanced:defineyourownvariable}{}
\todo{to complete}

\section{Model and Solver detectors}\label{advanced:detectors}\hypertarget{advanced:detectors}{}

Sometimes, on automatic code generation or during benchmarking, it could be useful to apply generic rules to analyze a \mylst{Model} and detect lacks of modeling and apply patchs. With Choco, this is possible using \mylst{ModelDetectorFactory} and \mylst{PreProcessCPSolver}.

\subsection{Model detector}\label{advanced:modeldetector}\hypertarget{advanced:modeldetector}{}

The analysis of a \mylst{Model} is done using the \mylst{ModelDetectorFactory}. First one declares the list of rules to apply, then they are applied to a specific model. 
This is done by using the follwing API:
\begin{lstlisting}
ModelDetectorFactory.run(CPModel model, AbstractDetector... detectors)
\end{lstlisting}
An \mylst{AbstractDetector} object describes the pattern to detect within the model and rules to apply. Applying a rule is commonly to refactor a given model, by adding or removing variables and constraints. 

\begin{note}
Calling \mylst{ModelDetectorFactory.run(..)} will produce a modified copy of the current model. 
Very few \mylst{AbstractDetector} just analyze the model, without any side effects.
\end{note}

\textbf{Detectors}


\begin{itemize}
\item[] \mylst{AbstractDetector analysis(CPModel m)} 
Analyze the model \mylst{m}, and print out messages about general statistics: very large domain variables, inappropriate domain type variables, free variables (variables not involved in any constraints), etc. 
\item[] \mylst{AbstractDetector intVarEqDet(CPModel m)}
\item[] \mylst{AbstractDetector taskVarEqDet(CPModel m)}
\item[] \mylst{AbstractDetector cliqueDetector(CPModel m, boolean breakSymetries)}
\item[] \mylst{AbstractDetector disjFromCumulDetector(CPModel m)}
\item[] \mylst{AbstractDetector precFromImpliedDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector precFromReifiedDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector precFromTimeWindowDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector precFromDisjointDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector disjointDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector disjointFromDisjDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector disjointFromCumulDetector(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector rmDisjDetector(final CPModel m)}
\item[] \mylst{AbstractDetector[] disjunctiveModelDetectors(CPModel m, DisjunctiveModel disjMod)}
\item[] \mylst{AbstractDetector[] schedulingModelDetectors(final CPModel m, DisjunctiveModel disjMod)}
\end{itemize}



\begin{note}
Analysing a \mylst{Model} can be time consuming. It should be used carefully.
\end{note}
 
 

\todo{to complete}


\subsection{Preprocess solver}\label{advanced:preprocesssolver}\hypertarget{advanced:preprocesssolver}{}

One may want to keep the \mylst{Model} unchanged but apply detection directly on the \mylst{Solver}. This can be done during the \textit{reading} step: the model is analyses on the fly and the rules are applied directly on the solver. 

To do that, simply replaced the \mylst{CPSolver} declaration by:
\begin{lstlisting}
Solver solver = new PreProcessCPSolver(); // new CPSolver();
\end{lstlisting} 

The rules that will be applied can be selected by updating the \mylst{PreProcessConfiguration} file.
\todo{to complete}


\section{Logging statements}\label{advanced:loggingstatements}\hypertarget{advanced:loggingstatements}{}

\subsection{Define your own logger.}\label{advanced:defineyourownlogger}\hypertarget{advanced:defineyourownlogger}{}
\begin{lstlisting}
ChocoLogging.makeUserLogger(String suffix);
\end{lstlisting}


\subsection{How to write logging statements ?}\label{advanced:howtowriteloggingstatements}\hypertarget{advanced:howtowriteloggingstatements}{}

\begin{itemize}
	\item Critical Loggers are provided to display error or warning. Displaying too much message really \textbf{impacts the performances}.
	\item Check the logging level before creating arrays or strings.
	\item Avoid multiple calls to \texttt{Logger} functions. Prefer to build a \texttt{StringBuilder} then call the \texttt{Logger} function.
	\item Use the \texttt{Logger.log} function instead of building string in \texttt{Logger.info()}.
\end{itemize}

\subsection{Handlers.}\label{advanced:handlers}\hypertarget{advanced:handlers}{}
Logs are displayed on \texttt{System.out} but warnings and severe messages are also displayed on \texttt{System.err}.
\texttt{ChocoLogging.java} also provides utility functions to easily change handlers:
\begin{itemize}
	\item Functions \texttt{set...Handler} remove current handlers and replace them by a new handler.
	\item Functions \texttt{add...Handler} add new handlers but do not touch existing handlers.
\end{itemize}

% \subsubsection{Figure source}\label{advanced:figuresource}\hypertarget{advanced:figuresource}{}
% \begin{lstlisting}
%   digraph G {
%       node [style=filled, shape=box];
%       choco [shape=house,fillcolor=gold];
	
%       kernel [shape=house,fillcolor=gold];
%       engine [shape=octagon,fillcolor=indianred];
%       search [shape=octagon,fillcolor=darkorange];
%       branching [shape=octagon,fillcolor=indianred];
	
%       api [shape=house,fillcolor=gold];
%       model [fillcolor=indianred];
%       solver [fillcolor=indianred];
%       parser [fillcolor=darkorange];
      
%       user [fillcolor=darkorange];
%       samples [fillcolor=darkorange];
      
%       test [fillcolor=indianred];
      
%       choco -> kernel;
%       choco -> API;
%       choco -> user;
%       choco -> test;
      
%       kernel -> engine;
%       kernel -> search;
      
%       api -> model;
%       api -> solver
%       api -> parser;
      
%       user  -> samples;
      
%       search -> branching;
% 	}
% \end{lstlisting}
