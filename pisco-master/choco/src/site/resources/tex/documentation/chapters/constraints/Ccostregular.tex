\hypertarget{costregular}{}

\section{costRegular (constraint)}\label{costregular:costregularconstraint}\hypertarget{costregular:costregularconstraint}{}
\begin{notedef}
  \texttt{costRegular}$(z, \collec{x_1}{x_n},\mathcal{L}(\Pi), \coll{c_{i,j}})$ states that sequence \collec{x_1}{x_n} is a word belonging to the regular language $\mathcal{L}(\Pi)$ and that $z$ is its cost computed as the sum of the individual symbol weights $c_{i,x_i}$:
$$ \collec{x_1}{x_n} \in \mathcal{L}(\Pi)\quad\land\quad \sum_{i=1}^n c_{i,x_i} = z.$$
\end{notedef}

Like \hyperlink{regular}{\texttt{regular}}, this constraint is useful for modelling sequencing rules in personnel scheduling and rostering problems. Furthermore it allows to handle a linear counter (or cost) on the sequence. See \hyperlink{multicostregular}{\texttt{multiCostRegular}} to simultaneously handle several linear counters.

\texttt{costRegular} is the optimization variant of the \hyperlink{regular:regularconstraint}{\texttt{regular}} constraint. Enforcing GAC is NP-Hard, then the implemented algorithm~\cite{DemasseyC06} achieves an intermediate AC-BC level of consistency. Let $\mathcal{L}_x=\mathcal{L}(\Pi)\cap (D_1\times\ldots\times D_n)$ be the set of words of the language $\mathcal{L}(\Pi)$ that can be matched by \collec{x_1}{x_n} according to their current domains \collec{D_1}{D_n}, then:  
      \begin{itemize}
      \item Arc Consistency is enforced over $x$ regarding the language and the lower and upper bounds of $z$: for each value $v\in D_i$, there exists a word in $\mathcal{L}_x$, with $v$ as its $i$-th symbol and whose cost is between the bounds of $z$.
      \item Bound Consistency is enforced over $z$ regarding $x$ and the language: the lower and upper bounds of $z$ are set as the minimum and maximum costs of any words in $\mathcal{L}_x$.
      \end{itemize}
In summary, \texttt{costRegular}$(z, x,\mathcal{L}(\Pi), c)$ dominates its decomposition \hyperlink{regular}{\texttt{regular}}$(x,\mathcal{L}(\Pi))\land$\hyperlink{equation}{\texttt{equation}}$(z, x, c)$. Another decomposition proposed in~\cite{BeldiceanuC05} can easily be generated by introducing intermediary cost variables \collec{z_1}{z_n} and state variables \collec{q_0}{q_n}, then posting constraints in extension on each tuple $(q_{i-1},x_i,q_i,z_i)$ with the $\Pi$ transition table, and one linear sum $z=z_1+\cdots+z_n$. In terms of consistency, the two approaches are incomparable (words with costs out of the bounds of $z$ may not be filtered by the decomposition, see examples in~\cite{MenanaCPAIOR09}).  

Several API exists for defining the regular language:
\begin{itemize}
\item With a deterministic finite automaton (DFA) $\Pi$ weighted by a cost table $c$ with two dimensions, then $c[i][j]$ is the cost of any transition in $\Pi$ labeled by $j$ when processing the $i$-th symbol of a word: it models the cost of assigning variable $x_i$ to value $j$. The constraint ensures that $z=\sum_i c[i][x_i]$.
\item With a DFA $\Pi$ weighted by a cost table $c$ with three dimensions, then $c[i][j][s]$ is the cost of the transition in $\Pi$ outgoing from state $s$ and labeled by $j$ when processing the $i$-th symbol of a word: it models the cost of assigning variable $x_i$ to value $j$ if assignment sequence $\collec{x_1}{x_{i-1}}$ reaches state $s$ when processed by $\Pi$.  The constraint ensures that $z=\sum_i c[i][x_i][s_i]$ where $\collec{s_0, s_1}{s_n}$ is the sequence of states encountered when recognizing $\collec{x_1}{x_{n}}$ in $\Pi$.
\item With a weighted valued multi-graph $G(\Pi)$ and a node $s$, then $G(\Pi)$ must be a layered graph with $n+1$ layers and $s$ be the unique node in layer 0. Such a graph defines a valued DFA, by setting the arcs as the transitions, the arc values as the transition labels, the arc weights as the transition costs, the nodes as the states, and the nodes in the last layer as the accepting states. Note that this DFA recognizes only words of length $n$. The constraint ensures that $z$ is the total weight of the path in $G(\Pi)$ produced when recognizing \collec{x_1}{x_n}.  
\end{itemize}

Automaton $\Pi$ is encoded as an object of class \texttt{FiniteAutomaton}, whose API contains:
\begin{lstlisting}
  FiniteAutomaton();
  FiniteAutomaton(String regularExpression);
  int addState();
  void setInitialState(int state); 
  void setFinal(int state); 
  void addTransition(int state1, int state2, int.. labels);
  FiniteAutomaton union(FiniteAutomaton a);
  FiniteAutomaton intersection(FiniteAutomaton a);
  FiniteAutomaton complement();
  void minimize();
  int getNbStates();
  void toDotty(String dotFileName);
\end{lstlisting}

\begin{itemize}
	\item \textbf{API} :
	\begin{itemize}
		\item \mylst{costRegular(IntegerVariable z, IntegerVariable[] x, FiniteAutomaton pi, int[][] c)}\\
based on the  \mylst{ConstraintType.COSTREGULAR} implementation
		\item \mylst{costRegular(IntegerVariable z, IntegerVariable[] x, FiniteAutomaton pi, int[][][] c)}\\
based on the  \mylst{ConstraintType.FASTCOSTREGULAR} implementation
		\item \mylst{costRegular(IntegerVariable z, IntegerVariable[] x, DirectedMultigraph<Node,Arc> g, Node s)}\\
based on the  \mylst{ConstraintType.FASTCOSTREGULAR} implementation
	\end{itemize}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} : \emph{n/a}
	\item \textbf{favorite domain} : \emph{n/a}
	\item \textbf{references} : \cite{DemasseyC06}: \emph{A \texttt{Cost-Regular} based hybrid column generation approach}
\end{itemize}



\textbf{Example}:

Build the \texttt{FiniteAutomaton} manually by adding states and transitions:
\lstinputlisting{java/ccostregular.j2t}

Build the \texttt{FiniteAutomaton} from a combination of several regular expressions: 
\lstinputlisting{java/ccostregular2.j2t}
