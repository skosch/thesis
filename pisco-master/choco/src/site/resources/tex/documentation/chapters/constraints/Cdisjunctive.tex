%\part{disjunctive}
\label{disjunctive}
\hypertarget{disjunctive}{}

\section{disjunctive (constraint)}\label{disjunctive:disjunctiveconstraint}\hypertarget{disjunctive:disjunctiveconstraint}{}
\todo{to be cleaned.}

\begin{notedef}
  \texttt{disjunctive(start,duration)} states that a set of tasks (defined by their starting times and durations) are executed on a ddisjunctive resource, i.e. they do not overlap in time:
$$|\{i\ |\ \mathtt{start}[i]\le t < \mathtt{start}[i]+\mathtt{duration}[i]\}| \le 1,\quad (\forall \text{ time } t)$$
\end{notedef}

\todo{The notion of task does not exist yet in Choco.} The \texttt{disjunctive} takes therefore as input arrays of integer variables (of same size $n$) denoting the starting and duration of each task. When the array of finishing times is also specified, the constraint ensures that \texttt{start[i] + duration[i] = end[i]} for all task $i$.
As usual, a task is executed in the interval \texttt{[start,end-1]}.

\begin{itemize}
	\item \textbf{API} :
	\begin{itemize}
		\item \mylst{disjunctive(IntegerVariable[] start, int[] duration, String...options)}
		\item \mylst{disjunctive(IntegerVariable[] start, IntegerVariable[] duration, String... options)}
		\item \mylst{disjunctive(IntegerVariable[] start, IntegerVariable[] end, IntegerVariable[] duration, String... options)}
		\item \mylst{disjunctive(IntegerVariable[] start, IntegerVariable[] end, IntegerVariable[] duration, IntegerVariable uppBound, String... options)}
	\end{itemize}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} :
	\begin{itemize}
		\item \emph{no option}
		\item \hyperlink{cdisjunctiveoc:cdisjunctiveocoptions}{SettingType.OVERLOAD\_CHECKING.getOptionName()} overload checking rule ( O(n*log(n)), Vilim), also known as task interval
		\item \hyperlink{cdisjunctivenfnl:cdisjunctivenfnloptions}{SettingType.NF\_NL.getOptionName()} NotFirst/NotLast rule ( O(n*log(n)), Vilim) (recommended)
		\item \hyperlink{cdisjunctivedp:cdisjunctivedpoptions}{SettingType.DETECTABLE\_PRECEDENCE.getOptionName()} Detectable Precedence rule ( O(n*log(n)), Vilim)
		\item \hyperlink{cdisjunctiveef:cdisjunctiveefoptions}{SettingType.EDGE\_FINDING\_D.getOptionName()} disjunctive Edge Finding rule ( O(n*log(n)), Vilim) (recommended)
		\item \hyperlink{cdisjunctivedf:cdisjunctivedfoptions}{SettingType.DEFAULT\_FILTERING.getOptionName()} use filtering algorithm proposed by Vilim. nested loop, each rule is applied until it reach it fixpoint		
		\item \hyperlink{cdisjunctivedf:cdisjunctivedfoptions}{SettingType.VILIM\_FILTERING.getOptionName()} use filtering algorithm proposed by Vilim. nested loop, each rule is applied until it reach it fixpoint
		\item \hyperlink{cdisjunctivesrf:cdisjunctivesrfoptions}{SettingType.SINGLE\_RULE\_FILTERING.getOptionName()} use filtering algorithm proposed by Vilim. nested loop, each rule is applied until it reach it fixpoint. A single filtering rule (debug only).					
	\end{itemize}
	\item \textbf{favorite domain} : \emph{n/a}
	\item \textbf{references} :\\
      global constraint catalog: \href{http://www.emn.fr/x-info/sdemasse/gccat/Cdisjunctive.html}{\tt disjunctive}
\end{itemize}

\textbf{Example}:
%\lstinputlisting{java/cdisjunctive.j2t}
\mylst{//TODO: complete} 
