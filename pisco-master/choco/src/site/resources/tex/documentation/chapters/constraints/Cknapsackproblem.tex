\section{knapsackProblem (constraint)}\label{knapsackproblem:knapsackproblemconstraint}\hypertarget{knapsackproblem:knapsackproblemconstraint}{}
\begin{notedef}
  \texttt{knapsackProblem}$(z^1, z^2, \collec{x_1}{x_n}, \collec{c^1_1}{c^1_n}, \collec{c^2_1}{c^2_n})$ states that $z^1$ (respectively, $z^2$) is the sum of the $x$ weighted by the costs $c^1$ (respectively, $c^2$):
$$\sum_{i=1}^{n}x_{i}c^1_{i}=z^1\quad \wedge\quad \sum_{i=1}^{n}x_{i}c^2_{i}=z^2$$
\end{notedef}
The knaspack problem can be modeled using only this constraint and the objective \mylst{maximize(z1)}: $x_i$ is the number of items of type $i$ and each item of type $i$ has a value $c^1_i$ and a weight $c^2_i$.
Based on \hyperlink{costregular:costregularconstraint}{\texttt{costRegular}}, this propagator simulates the dynamic programming approach of~\cite{TrickAOR03}.
It dominates the filtering of the decomposition in two \hyperlink{equation}{\texttt{equation}} constraints.

\begin{itemize}
	\item \textbf{API} : \mylst{knapsackProblem(IntegerVariable z1, IntegerVariable z2, IntegerVariable[] x, int[] c1, int[] c2)}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} : \emph{n/a}
	\item \textbf{favorite domain} : \emph{n/a}
	\item \textbf{references} : 
		\cite{TrickAOR03}: \emph{A Dynamic Programming Approach for Consistency and Propagation for Knapsack Constraints}
\end{itemize}

\textbf{Example}:
\lstinputlisting{java/cknapsack.j2t}

