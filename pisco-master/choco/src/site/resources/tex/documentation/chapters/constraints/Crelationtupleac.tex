%\part{relationtupleac}
\label{relationtupleac}
\hypertarget{relationtupleac}{}

\section{relationTupleAC (constraint)}\label{relationtupleac:relationtupleacconstraint}\hypertarget{relationtupleac:relationtupleacconstraint}{}
\begin{notedef}
  \texttt{relationTupleAC}$(x,rel)$ states an extensional constraint on $(x_1,\ldots,x_n)$ defined by the $n$-ary relation $rel$, and then enforces arc consistency:
$$(x_1,\ldots,x_n)\in rel$$
\end{notedef}
Many constraints of the same kind often appear in a model. Relations can therefore often be shared among many constraints to spare memory.
The API is duplicated to define options.

\begin{itemize}
	\item \textbf{API}:
	\begin{itemize}
		\item \mylst{relationTupleAC(IntegerVariable[] x, LargeRelation rel)}
		\item \mylst{relationTupleAC(String options, IntegerVariable[] x, LargeRelation rel)}
	\end{itemize}
	\item \textbf{return type}: \texttt{Constraint}
	\item \textbf{options} :
	\begin{itemize}
		\item \emph{no option}: use AC32 (default arc consistency)
		\item \hyperlink{cext32:cext32options}{\tt Options.C\_EXT\_AC32}: to get AC3rm algorithm (maintaining the current support of each value in a non backtrackable way)
		\item \hyperlink{cext2001:cext2001options}{\tt Options.C\_EXT\_AC2001}: to get AC2001 algorithm (maintaining the current support of each value)
		\item \hyperlink{cext2008:cext2008options}{\tt Options.C\_EXT\_AC2008}: to get AC2008 algorithm (maintained by STR)
	\end{itemize}
	\item \textbf{favorite domain} : \emph{to complete}
\end{itemize}

\textbf{Example} :
\lstinputlisting{java/cnotallequal.j2t}
\lstinputlisting{java/crelationtupleac.j2t}