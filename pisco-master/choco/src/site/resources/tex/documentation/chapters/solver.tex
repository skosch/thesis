%!TEX root = ../content-doc.tex
%\part{solver}
\label{solver}
\hypertarget{solver}{}


\chapter{The solver}\label{solver:thesolver}\hypertarget{solver:thesolver}{}

%\section{How to create a solver}\label{solver:howtocreateasolver}\hypertarget{solver:howtocreateasolver}{}


\newglossaryentry{Solver}{name={Solver},description={solver description}}
The \mylst{Solver}, along with the \mylst{Model}, is one of the two key elements of any Choco program. The Choco \mylst{Solver} is mainly focused on resolution part: reading the \mylst{Model}, defining the search strategies and the resolution policy.  

To create a \gls{Solver}, one just needs to create a new object as follow:
\begin{lstlisting}
Solver solver = new CPSolver();
\end{lstlisting}
This instruction creates a Constraint Programming (CP) {\tt Solver} object.

%\section{Read a model}\label{solver:readamodel}\hypertarget{solver:readamodel}{}
The solver gives an API to read a model. The reading of a model is compulsory and must be done after the entire definition of the model. 
\begin{lstlisting}
solver.read(model);
\end{lstlisting}
The reading is divided in two parts: \hyperlink{solver:variablesreading}{variables reading} and \hyperlink{solver:constraintsreading}{constraints reading}.

\section{Variables reading}\label{solver:variablesreading}\hypertarget{solver:variablesreading}{}
The variables are declared in a model with a given type \texttt{IntegerVariable, SetVariable, RealVariable} and, possibly, with a given domain type (e.g. bounded or enumerated domains for integer and set variables).
When reading the model, the solver iterates over the model variables, then creates the corresponding solver variables and domains data structures according to these types.

\begin{note}
\textbf{Bound variables} are related to large domains which are only represented by their lower and upper bounds. The domain is encoded in a space efficient way and propagation events only concern bound updates. Value removals between the bounds are therefore ignored (\emph{holes} are not considered). The level of consistency achieved by most constraints on these variables is called \emph{bound-consistency}.

On the contrary, the domain of an \textbf{enumerated variable} is explicitly represented and every value is considered while pruning. Basic constraints are therefore often able to achieve \emph{arc-consistency} on enumerated variables (except for NP-hard global constraint such as the cumulative constraint). Remember that switching from enumerated variables to bounded variables decreases the level of propagation achieved by the system.
\end{note}


%\begin{note}
\paragraph{Model variables and solver variables are distinct objects.} 
Model variables implement the \mylst{Variable} interface and solver variables implement the \mylst{Var} interface.
A model variable is defined by an abstract representation of its initial domain, while a solver variable encapsulates a concrete representation of the domain, and maintains its current state throughout the search.
Hence, one cannot access a variable value directly from a model variable but one can from its corresponding solver variable. The solver variables are anonymous but can be accessed from the corresponding model variables using the \texttt{Solver} API \mylst{getVar(Variable v)} and \mylst{getVar(Variable... v)}.
%To access to a model variable thanks to the solver, use the following 
%\end{note}

\subsection{from \texttt{IntegerVariable} to\texttt{IntDomainVar}}\label{solver:solverandintegervariables}\hypertarget{solver:solverandintegervariables}{}

For integer variables, the solver \textbf{\tt IntDomainVar} is counterpart to the model \hyperlink{integervariable}{\textbf{\tt IntegerVariable}}. 
Methods \textbf{\tt getVar(IntegerVariable var)} and \textbf{\tt getVar(IntegerVariable... vars)} of \texttt{Solver} return the objects \texttt{IntDomainVar} and \texttt{IntDomainVar[]} respectively corresponding to \texttt{var} and \texttt{vars}:
\begin{lstlisting}
  IntegerVariable x = Choco.makeEnumIntVar("x", 1, 100);  // model variable
  IntDomainVar xOnSolver = solver.getVar(x);  // solver variable
\end{lstlisting}

The state of an \texttt{IntDomainVar} can be accessed using these main public methods:

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{IntDomainVar} API &  description \\
  \hline
	\mylst{hasEnumeratedDomain()} &checks if the domain type is enumerated or bounded\\
	\mylst{getInf()} &returns the current lower bound of the variable\\
	\mylst{getSup()} &returns the current upper bound of the variable\\
	\mylst{getVal()} &returns the value of the variable if it is currently instantiated\\
	\mylst{isInstantiated()} &checks if the domain is currently reduced to a singleton\\
	\mylst{canBeInstantiatedTo(int v)} &checks if value \texttt{v} currently belongs to the domain of the variable\\
	\mylst{getDomainSize()} &returns the current size of the domain\\
  \hline\\
\end{tabular}

The data structure representing the current domain within the \texttt{IntDomainVar} object depends on the domain type (bounded, enumerated, boolean, constant, etc.) of the model variable. 
See \hyperlink{advanced}{advanced uses} for more informations on \texttt{IntDomainVar}.

\subsection{from \texttt{SetVariable} to \texttt{SetVar}}\label{solver:solverandsetvariables}\hypertarget{solver:solverandsetvariables}{}

For set variables, the solver \textbf{\tt SetVar} is counterpart to the model \hyperlink{setvariable}{\textbf{\tt SetVariable}}. 
Methods \textbf{\tt getVar(SetVariable var)} and \textbf{\tt getVar(SetVariable... vars)} of \texttt{Solver} return the objects \texttt{SetVar} and \texttt{SetVar[]} respectively corresponding to \texttt{var} and \texttt{vars}:
\begin{lstlisting}
	SetVariable x = Choco.makeBoundSetVar("x", 1, 40); // model variable
	SetVar xOnSolver = solver.getVar(x); // solver variable
\end{lstlisting}

Note that a set variable on integer values between $1$ and $n$ may have $2^{n}$ possible values, corresponding to every possible subsets of $\{1,2,\ldots,n\}$. Hence, the domain of a \texttt{SetVar} is encoded by these bounds only: the lower bound, called the \emph{kernel}, is the intersection of all possible set values, and the upper bound, called the \emph{envelope}, is the union of all possible set values. Furthermore, a \texttt{SetVar} encapsulates an \texttt{IntDomainVar} representing the cardinality of the set variable. The domain type of this variable (enumerated or bounded) depends on the option given at the construction of the \texttt{SetVariable}. 
%This makes an exponential number of values and the domain is represented with two bounds corresponding to the intersection of all possible sets (called the kernel) and the union of all possible sets (called the envelope) which are the possible candidate values for the variable.

The state of a \texttt{SetVar} can be accessed through these main public methods: \todo{Warning: Envelope is (french) spelled with two 'p' in the method name.}

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{SetVar} API &  description \\
  \hline
	\mylst{getCard()} &returns the current cardinality (an \texttt{IntDomainVar} object)\\
	\mylst{isInDomainKernel(int v)} &checks if value \texttt{v} belongs to the current kernel\\
	\mylst{isInDomainEnveloppe(int v)} &checks if value \texttt{v} belongs to the current envelope\\
	\mylst{getDomain()} &returns the current domain (a \texttt{SetDomain} object). Iterators on envelope or kernel can then be called\\
	\mylst{getKernelDomainSize()} &returns the current size of the kernel\\
	\mylst{getEnveloppeDomainSize()} &returns the current size of the envelope\\
	\mylst{getEnveloppeInf()} &returns the current smallest value of the envelope\\
	\mylst{getEnveloppeSup()} &returns the current largest value of the envelope\\
	\mylst{getKernelInf()} &returns the current smallest value of the kernel\\
	\mylst{getKernelSup()} &returns the current largest value of the kernel\\
	\mylst{getValue()} &returns the set value as a table of integers \texttt{int[]} when the variable is currently instantiated (kernel=envelope)\\
  \hline\\
\end{tabular}

\noindent See \hyperlink{advanced}{advanced uses} for more informations on \texttt{SetVar}.

\subsection{from \texttt{RealVariable} to \texttt{RealVar}}\label{solver:solverandrealvariables}\hypertarget{solver:solverandrealvariables}{}

\begin{note}
\emph{Real variables are still under development but can be used to solve toy problems such as small systems of equations.}
\end{note}
 
For real variables, the solver \textbf{\tt RealVar} is counterpart to the model \hyperlink{realvariable}{\textbf{\tt RealVariable}}. 
Methods \textbf{\tt getVar(RealVariable var)} and \textbf{\tt getVar(RealVariable... vars)} of \texttt{Solver} return the objects \texttt{RealVar} and \texttt{RealVar[]} respectively corresponding to \texttt{var} and \texttt{vars}:
\begin{lstlisting}
	RealVariable x = Choco.makeRealVar("x", 1.0, 3.0); // model variable
	RealVar xOnSolver = solver.getVar(x); // solver variable
\end{lstlisting}

Continuous variables are useful for non linear equation systems which are encountered in physics for example.
The state of a \texttt{RealVar} can be accessed through these main public methods:

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{RealVar} API &  description \\
  \hline
	\mylst{getInf()} &returns the current lower bound of the variable (\texttt{double})\\
	\mylst{getSup()} &returns the current upper bound of the variable (\texttt{double})\\
	\mylst{isInstantiated()} &checks if the domain is reduced to a canonical interval. A canonical interval indicates that the domain has reached the precision given by the user or the solver\\
  \hline\\
\end{tabular}

\noindent See \hyperlink{advanced}{advanced uses} for more informations on \texttt{RealVar}.

\subsection{from \texttt{TaskVariable} to \texttt{TaskVar}}\label{solver:solverandtaskvariables}\hypertarget{solver:solverandtaskvariables}{}

For task variables, the solver \textbf{\tt TaskVar} is counterpart to the model \hyperlink{taskvariable}{\textbf{\tt TaskVariable}}. 
Methods \textbf{\tt getVar(TaskVariable var)} and \textbf{\tt getVar(TaskVariable... vars)} of \texttt{Solver} return the objects \texttt{TaskVar} and \texttt{TaskVar[]} respectively corresponding to \texttt{var} and \texttt{vars}:
\begin{lstlisting}
	TaskVariable x = Choco.makeTaskVar("x", 0, 123, 18); // model variable
	TaskVar xOnSolver = solver.getVar(x); // solver variable
\end{lstlisting}

Task variables help at formulating scheduling problems where one has to determine the starting and ending time of a task. A task variable aggregates three integer variable: \texttt{start}, \texttt{end}, and \texttt{duration} and the implicit constraint \texttt{start}+\texttt{duration}=\texttt{end}. 

\todo{To complete.}
The state of a \texttt{TaskVar} can be accessed through these main public methods:

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{TaskVar} API &  description \\
  \hline
	\mylst{isInstantiated()} &checks if the three time integer variables are instantiated\\
  \hline\\
\end{tabular}

\noindent See \hyperlink{advanced}{advanced uses} for more informations on \texttt{TaskVar}.

\section{Constraints reading}\label{solver:constraintsreading}\hypertarget{solver:constraintsreading}{}
Once the solver variables are created when reading the model, the solver then iterates over the constraints of the model, and creates the solver \texttt{SConstraint} objects  by calling method \texttt{makeConstraint} of the \texttt{ConstraintManager} object associated to the model constraint type.
At this step, auxiliary solver variables and constraints may be generated. The created constraints are then added to the internal constraint network. 

Each solver constraint encapsulates a filtering algorithm which is called, during the search, when a propagation step occurs or when an external event (e.g., value removal or bound modification) happens on some variable of the constraint.

One can access the Solver representation of a Model constraint, using the \texttt{Solver} API \mylst{getCstr(Constraint c)}.

\section{Solve a problem}\label{solver:solveaproblem}\hypertarget{solver:solveaproblem}{}
%As Solver is the second element of a Choco program, the control of the search process without using predefined tools is made on the Solver.

Table below presents the different API offered by \texttt{Solver} to launch the problem resolution. All these methods return a \texttt{Boolean} object standing for the \emph{problem feasibility status} of the solver:
$$\begin{cases}
  \texttt{Boolean.TRUE} &\text{ if at least one feasible solution has been computed},\\
  \texttt{Boolean.FALSE} &\text{ if the problem is proved to be infeasible},\\
  \texttt{null} &\text{ otherwise, i.e. when a search limit has been reached before.}
\end{cases}$$

\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
  \hline
  \texttt{Solver} API & description \\
  \hline
      \mylst{solve()} or \mylst{solve(false)} &  runs backtracking until reaching \emph{a first feasible solution} (returns \mylst{Boolean.TRUE}) or the proof of infeasibility (returns \mylst{Boolean.FALSE}) or a search limit (returns \mylst{null}).\\[.3em]
      \hline\\
      \mylst{nextSolution()} &  Can only be called after a \texttt{solve()} or a \texttt{nextSolution()} call that has returned \mylst{Boolean.TRUE}. Runs backtracking, from the solution leaf reached by the previous \texttt{solve()} or \texttt{nextSolution()} call, until reaching \emph{a new feasible solution} (returns \mylst{Boolean.TRUE}), or proving no such new solution exists (returns \texttt{Boolean.FALSE}), or reaching a search limit (returns \mylst{null}).\\[.3em]
      \hline\\
      \mylst{isFeasible()} &  Returns the feasibility status of the solver.\\
      \hline\\
      \mylst{solveAll()} or \mylst{solve(true)} &  Runs backtracking until computing \emph{all feasible solutions}, or until proving infeasibility (returns \mylst{Boolean.FALSE}) or until reaching a search limit (returns \mylst{Boolean.TRUE} if at least one first solution was computed, and \mylst{null} otherwise). \\[.3em]
      \hline\\
      \mylst{maximize(Var obj, boolean restart),}\mylst{maximize(boolean restart)} &  Runs branch-and-bound until reaching \emph{a feasible solution that is proved to maximize objective} \mylst{obj},  or until proving infeasibility (returns \mylst{Boolean.FALSE}) or until reaching a search limit (returns \mylst{Boolean.TRUE} if at least one first solution was computed, and \mylst{null} otherwise). It proceeds by successive improvements of the best solution found so far: each time a feasible solution is found at a leaf of the tree search, then the search proceeds for a new solution with a greater objective, until it proves that no such improving solution exists.
Parameter \texttt{restart} is a boolean indicating whether the search continues from the solution leaf with a backtrack (if set to \mylst{false}) or if it is restarted from the root node (if set to \texttt{true}).\\
\hline\\
      \mylst{minimize(Var obj, boolean restart),}\mylst{minimize(boolean restart)} &  similar to \texttt{maximize} but for computing \emph{a feasible solution that is proved to minimize objective} \texttt{obj}.\\[.3em]      \hline\\
	\end{tabular}

The following  API are also useful to manipulate a \texttt{Solver} object:\\
\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
  \hline
  \texttt{Solver} API & description \\
  \hline
      \mylst{propagate()} &  Launchs propagation by running, in turn, the domain reduction algorithms of the constraints until it reaches a fix point. Throws a \texttt{ContradictionException} when a contradiction is detected, i.e. a variable domain is emptied. This method is called at each node of the tree search constructed by the solving methods above.\\[.3em]
      \hline\\
	\end{tabular}

\section{Storing et restoring solutions}\label{}\hypertarget{}{}
By default, the last solution found is stored and accessible once the search has ended.

\paragraph{Store solutions.} To store the solutions found during the resolution, one just needs to override the solution pool capacity (which is set to 1 by default).
\begin{lstlisting}
	int size = Integer.MAX_VALUE;
	solver.getConfiguration().putInt(Configuration.SOLUTION_POOL_CAPACITY, size);
	solver.solveAll();
	ISolutionPool pool = solver.getSearchStrategy().getSolutionPool();
\end{lstlisting}

Setting \textit{size} to \mylst{Integer.MAX\_VALUE} means ``store every solution'', otherwise you can set a finite value, for example 10 and the last 10 solutions will be stored.

A Solution object is made of arrays of values: an array of values of \mylst{IntVar}, another one for values of \mylst{SetVar} and the last one for the values of \mylst{RealVar}. One can retrieve the value of a variable by calling \mylst{getXXValue(int idx)}, where \mylst{XX} is the type of variable and \mylst{idx} is its index within the solver:

\begin{lstlisting}
	solution.getIntValue(solver.getIntVarIndex(ivar));
	solution.getSetValue(solver.getSetVarIndex(svar));
	solution.getRealValue(solver.getRealVarIndex(fvar));
\end{lstlisting}

And to make the link between a variable in a solution, simply retrieve the index of the variable in the solver:
\begin{lstlisting}
	int q0 = solver.getIntVarIndex(solver.getVar(vars[0])); // vars is an array of IntegerVariable
	solution.getIntValue(q0);
\end{lstlisting}

\paragraph{Restore solutions.} A solution can be restored within a solver. But to do that, some precautions must be made: before starting the search, the state of the solver must be backed up.
\begin{lstlisting}
	int rootworld = solver.getEnvironment().getWorldIndex();
	solver.worldPush();
	solver.solveAll();
\end{lstlisting}

And then, to restore, first restore the root world and backup another world:
\begin{lstlisting}
	solver.worldPopUntil(rootworld); // restore the original state, where domains were as declared (not yet instantiated)
	solver.worldPush(); // backup the current state of the solver, to allow other solution restoration
	solver.restoreSolution(solution); // restore the solution
	// do something
\end{lstlisting}
If you want to restore more than one solution, you just apply this 3 steps.

\section{Search Strategy}\label{solver:searchstrategy}\hypertarget{solver:searchstrategy}{}

\newglossaryentry{branching strategy}{name={branching strategy}, plural={branching strategies},description={heuristic controlling the execution of a search loop at a point where the control flow may be split between different branches}}
\newglossaryentry{search strategy}{name={search strategy}, plural={search strategies},description={composition of branching strategies}}

A key ingredient of any constraint approach is a clever \gls{search strategy}. 
In backtracking or branch-and-bound approaches, the search is organized as an enumeration tree, where each node corresponds to a subspace of the search, and each child node is a subdivision of its father node's space.
The tree is progressively constructed by applying a series of \glspl{branching strategy} that determine how to subdivise space at each node and in which order to explore the created child nodes. Branching strategies play the role of achieving intermediate goals in logic programming. 

This section presents how to define your own search strategy in Choco. 
\begin{note}
  Standard backtracking or branch-and-bound approaches in constraint programming develop the enumeration tree in a \textbf{Depth-First Search (DFS)} manner:
  \begin{enumerate}
  \item \emph{evaluate} a node: run propagation 
  \item if a failure occurs or if the search space cannot be separated then \emph{backtrack}: evaluate the next pending node
  \item otherwise \emph{branch}: divide the search space and evaluate the first child node.
  \end{enumerate}
  With Choco, the search process of the \texttt{CPSolver} does not currently allow to explore the tree in a different manner, using Best-First Search for example. 

  In addition, the common way of dividing the search space in CP-based backtracking/B\&B algorithms is \textbf{to assign a variable to a value or to forbid this assignment}. Choco provides such a branching strategy and the tools to easily customize the variable and value selection heuristics within this strategy. However, Choco makes possible to implement \textbf{more complex branching strategies} (e.g. constraint branching or dichotomy branching).
\end{note}

%The user may specify the sequence of branching strategies to be used to build the search tree. We will present in this section how to define your branching strategies.

\subsection{Overriding the default search strategy}\label{solver:overridethedefaultsearchstrategy}\hypertarget{solver:overridethedefaultsearchstrategy}{}

\newglossaryentry{value selector}{name={value selector}, plural={value selector},description={heuristic specifying how to choose a value from a chosen variable at a fix point}}
\newglossaryentry{value iterator}{name={value iterator}, plural={value iterators},description={heuristic specifying how to choose a value from a chosen variable, through an iterator, at a fix point}}
\newglossaryentry{variable selector}{name={variable selector}, plural={variable selectors},description={heuristic specifying how to choose a variable at a fix point}}


%Basically, a search strategy is the composition of three objects: a \gls{branching strategy}, a \gls{variable selector} and a \gls{value selector} (or a \gls{value iterator}). Some branching strategies simply assign a selected value to a selected variable, like \hyperlink{assignvar:assignvarbranchstrat}{AssignVar}, others branching strategies embed the variable selector, like \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew}, or more, like  \hyperlink{impact:impactbranchstrat}{ImpactBasedBranching}.
\paragraph{Branching, variable selection and value selection strategies.}
Basically, a search strategy in Choco is a composition of \gls{branching strategy} objects, each defined on a given set of decision variables.
The most common branching strategies are based on the assignment of a selected variable to one or several selected values (one assignment in each branch). 
\begin{note}
Branching strategies apply to \texttt{Solver} variables (not \texttt{Model} variables).
\end{note}
The variable and value selection heuristics can be defined separately in their own objects: a \gls{variable selector} and a \gls{value selector} or a \gls{value iterator}. 
Branching strategy \hyperlink{assignvar:assignvarbranchstrat}{\tt AssignVar}, for example, can simply be customized via these embedded objects: the variable is first selected, then a value in the variable domain is selected. The two following instructions both create a $n$-ary branching strategy (\texttt{AssignVar}) selecting an integer decision variable of minimum domain size (\texttt{MinDomain} variable selector) and assigning it successively, in each branch, to one of its domain value, selected in increasing order (\texttt{IncreasingDomain} value iterator or \texttt{MinVal} value selector).
\begin{lstlisting}
  new AssignVar(new MinDomain(solver), new IncreasingDomain());
  new AssignVar(new MinDomain(solver), new MinVal());
\end{lstlisting}
Note that this usual strategy is pre-defined in \texttt{BranchingFactory}, and may then also be declared as follows:
\begin{lstlisting}
  BranchingFactory.minDomMinVal(solver);
\end{lstlisting}
Sometimes, the choice of the variable may also depend on the choice of the value, or it may require specific computations before or after branching. In this case, the variable selection heuristic can directly be implemented in the branching strategy object, like e.g. in \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew}. Both variable and value selection heuristics can be implemented directly within the branching strategy, like e.g in \hyperlink{impact:impactbranchstrat}{ImpactBasedBranching}.

\paragraph{Default strategies.}
When no search strategy is specified, default search strategies apply to all the decision variables of the solver.
These strategies vary according to the variable types: 

\noindent\begin{tabular}{p{.25\linewidth}p{.7\linewidth}}
\hline
Variable type &  Default strategy \\
\hline
Set &   \hyperlink{assignsetvar:assignsetvarbranchstrat}{AssignSetVar} + \hyperlink{mindomset:mindomsetvarselector}{MinDomainSet} + \hyperlink{minenv:minenvvalselector}{MinEnv} \\
Integer & \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew} +\hyperlink{increasingdomain:increasingdomainvaliterator}{IncreasingDomain}\\
 Real &  \hyperlink{assigninterval:assignintervalbranchstrat}{AssignInterval} + \hyperlink{cyclicrealvarselector:cyclicrealvarselectorvarselector}{CyclicRealVarSelector}+ \hyperlink{realincreasingdomain:realincreasingdomainvaliterator}{RealIncreasingDomain} \\
\hline\\
\end{tabular}
If the model has decision variables of different types, then these default branchings are evaluated in this order: first, the set decision variables are considered until they are all instantiated, then branching occurs on the pool of integer decision variables, and last on the pool of real decision variables.

\paragraph{Decision variables.}
Branchings apply to decision variables only. A branching can occur (i.e. the tree node can be separated according to this strategy) if and only if there exists a decision variable in its scope that is still not instantiated.
The non-decision variables are also called \emph{implied variables} because it is expected that, all variables -- including these -- will be instantiated (i.e. they will form a solution) by propagation as soon as all the decision variables will be instantiated. Consider for example, a problem with two sets of variables $x$ and $y$ linked by channeling or by some implication $x=S\implies y=T$ then the $x$ variables can be set as the decision variables, the $y$ will be instantiated by side-effect. 

By default, every solver variable belongs to the pool of decision variables, unless:
\begin{itemize}
\item it corresponds to a model variable created with flag \hyperlink{vnodecision:vnodecisionoptions}{\tt Options.V\_NO\_DECISION};
\item or it is internally created by the solver (e.g. when reading some model constraint) and explicitely excluded from the pool;
\item or the default branching strategies are overriden and the variable does not belong to the scope of one of the strategies specified by the user.
\end{itemize}

The scope of a branching strategy is defined at the creation of the strategy. For example,
\begin{lstlisting}
  new AssignSetVar(new MinDomSet(solver, solver.getVar(svars)), new MinEnv()));
\end{lstlisting}
defines a branching strategy that only applies to the solver variables corresponding to the model set variables \texttt{svars} (even if they were defined with flag \hyperlink{vnodecision:vnodecisionoptions}{\tt Options.V\_NO\_DECISION}).

Most branching strategies may be declared without specifying their scope. In this case, they apply to all the solver decision variables of the right type. For example, the branching strategy
\begin{lstlisting}
  new AssignSetVar(new MinDomSet(solver), new MinEnv()));
\end{lstlisting}
now applies to all the solver decision set variables.

If the default strategies of the solver are overridden by this strategy alone, then all other integer and real variables will automatically be removed from the decision pool: one has then to ensure that the instantiation of the set variables alone defines a complete solution.
If it is not the case, the branching strategy must be combined with additional branching strategies holding on the remaining unimplied variables.
\begin{note}
  If the default strategies are overriden, then the pool of decision variables is overriden by the union of the scopes of the user-specified branching strategies.
\end{note}
As the branching strategies are evaluated sequentially, a variable may belong to the scope of two different strategies, but it will only be considered by the first strategy, unless this first (user-defined) strategy let the variable un-instantiated.

\paragraph{Overriding the default search strategies.}
A branching strategy is added to the solver, as a goal, using the following API of \texttt{Solver}:
\begin{lstlisting}
  void addGoal(AbstractIntBranchingStrategy branching);
\end{lstlisting}
This method must be called on the solver object \emph{before} calling the solving method.
The initial list of goals is empty. If goals are specified, they are added to the list in the order of their declaration.
Otherwise, the list is initialized with the default goals (in the order: set, integer, real).

When one wants to relaunch the search, the list of goals of the solver can previously be reset using the following instruction:
\begin{lstlisting}
  solver.clearGoals();
\end{lstlisting} 

\paragraph{Complete example.}
The following example adds four branching objects to solver \texttt{s}. 
%on integer variables \texttt{vars1}, \texttt{vars2} and set variables \texttt{svars} . 
The first two branchings are both \texttt{AssignVar} strategies using different variable/value selection heuristics and applied to different scopes: the integer variables \texttt{vars1} and \texttt{vars2}, respectively. The third strategy applies to the set variables \texttt{svars}. The last random strategy applies to all the integer decision variables of the solver.
%  s.addGoal(new AssignVar(new MinDomain(s,s.getVar(vars1)), new IncreasingDomain()));
\begin{lstlisting}
  s.addGoal(BranchingFactory.minDomMinVal(s, s.getVar(vars1)));
  s.addGoal(new AssignVar(new DomOverDeg(s, s.getVar(vars2)), new DecreasingDomain()));
  s.addGoal(new AssignSetVar(new MinDomSet(s, s.getVar(svars)), new MinEnv()));
  s.addGoal(BranchingFactory.randomIntSearch(s, seed));
  s.solve();
\end{lstlisting}
The goals are evaluated in this order: first, variables \texttt{vars1} are considered until they are all instantiated, then branching occurs on variables \texttt{vars2}, then on variables \texttt{svars}. Finally, a random strategy is applied to all the integer decision variables of the solver that are not already instantiated, thereby excluding variables \texttt{vars1} and \texttt{vars2}.

\subsection{Pre-defined search strategies}\label{solver:predefinedsearchstrategy}\hypertarget{solver:predefinedsearchstrategy}{}

This section presents the strategies available in Choco. These objects are also detailed in Part \hyperlink{part:elements}{Elements of Choco}.
See Chapter \hyperlink{advanced}{advanced uses} for a description of how to write search strategies in Choco.

\paragraph{Branching strategy}\label{solver:branchstrat}\hypertarget{solver:branchstrat}{}
defines the way to branch from a tree search node.
  
\noindent The \textbf{branching strategies} currently available in Choco are the following: 
\begin{notedef}\tt
\hyperlink{assigninterval:assignintervalbranchstrat}{AssignInterval}, \hyperlink{assignorforbidintvarval:assignorforbidintvarvalbranchstrat}{AssignOrForbidIntVarVal}, \hyperlink{assignorforbidintvarvalpair:assignorforbidintvarvalpairbranchstrat}{AssignOrForbidIntVarValPair}, \hyperlink{assignsetvar:assignsetvarbranchstrat}{AssignSetVar}, \hyperlink{assignvar:assignvarbranchstrat}{AssignVar}, \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew}, \hyperlink{domoverwdegbin:domoverwdegbinbranchstrat}{DomOverWDegBinBranchingNew}, \hyperlink{impact:impactbranchstrat}{ImpactBasedBranching}, \hyperlink{packdynremovals:packdynremovalsbranchstrat}{PackDynRemovals}, \hyperlink{settimes:settimesbranchstrat}{SetTimes}, \hyperlink{taskdomoverwdeg:taskdomoverwdegbranchstrat}{TaskOverWDegBinBranching}.
\end{notedef} 
They implement interface \texttt{BranchingStrategy}.   


\paragraph{Variable selector}\label{solver:variableselector}\hypertarget{solver:variableselector}{}
defines the way to choose a non instantiated variable on which the next decision will be made.

\noindent The \textbf{variable selectors} currently available in Choco are the following: 
\begin{itemize}
\item implementing interface \texttt{VarSelector<IntDomainVar>}:
\begin{notedef}\tt
\hyperlink{compositeintvarselector:compositeintvarselectorvarselector}{CompositeIntVarSelector}, \hyperlink{lexintvarselector:lexintvarselectorvarselector}{LexIntVarSelector}, \hyperlink{maxdomain:maxdomainvarselector}{MaxDomain}, \hyperlink{maxregret:maxregretvarselector}{MaxRegret}, \hyperlink{maxvaldomain:maxvaldomainvarselector}{MaxValueDomain}, \hyperlink{mindomain:mindomainvarselector}{MinDomain}, \hyperlink{minvaldomain:minvaldomainvarselector}{MinValueDomain}, \hyperlink{mostconstrained:mostconstrainedvarselector}{MostConstrained},  \hyperlink{randomvarint:randomvarintvarselector}{RandomIntVarSelector},  \hyperlink{staticvarorder:staticvarordervarselector}{StaticVarOrder}
\end{notedef}
%\noindent The \textbf{set variable selectors} currently available in Choco are the following: 
\item implementing interface \texttt{VarSelector<SetVar>}:   
\begin{notedef}\tt
\hyperlink{maxdomset:maxdomsetvarselector}{MaxDomSet}, \hyperlink{maxregretset:maxregretsetvarselector}{MaxRegretSet}, \hyperlink{maxvaldomset:maxvaldomsetvarselector}{MaxValueDomSet}, \hyperlink{mindomset:mindomsetvarselector}{MinDomSet}, \hyperlink{minvaldomset:minvaldomsetvarselector}{MinValueDomSet}, \hyperlink{mostconstrainedset:mostconstrainedsetvarselector}{MostConstrainedSet},  \hyperlink{randomvarset:randomvarsetvarselector}{RandomSetVarSelector},  \hyperlink{staticsetvarorder:staticsetvarordervarselector}{StaticSetVarOrder}
\end{notedef}
%\noindent The \textbf{real variable selector} currently available in Choco is the following: 
\item implementing interface \texttt{VarSelector<RealVar>}:
\begin{notedef}\tt
\hyperlink{cyclicrealvarselector:cyclicrealvarselectorvarselector}{CyclicRealVarSelector}
\end{notedef}
\end{itemize}

\subsubsection{Value iterator}\label{solver:valueiterator}\hypertarget{solver:valueiterator}{}
Once the variable has been choosen, the solver has to compute its value. The first way to do it is to schedule all the values once and to give an iterator to the solver.

\noindent The \textbf{value iterators} currently available in Choco are the following: 
\begin{itemize}
\item implementing interface \texttt{ValIterator<IntDomainVar>}:
\begin{notedef}\tt
\hyperlink{decreasingdomain:decreasingdomainvaliterator}{DecreasingDomain}, \hyperlink{increasingdomain:increasingdomainvaliterator}{IncreasingDomain}
\end{notedef}
\item implementing interface \texttt{ValIterator<RealVar>}:
\begin{notedef}\tt
\hyperlink{realincreasingdomain:realincreasingdomainvaliterator}{RealIncreasingDomain}
\end{notedef}
\end{itemize}

\subsubsection{Value selector}\label{solver:valueselector}\hypertarget{solver:valueselector}{}
The second way to do it is to compute the next value at each call.

\noindent The \textbf{integer value selector} currently available in Choco are the following: 
\begin{itemize}
\item implementing interface \texttt{ValSelector<IntDomainVar>}:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{maxval:maxvalvalselector}{MaxVal}, \hyperlink{midval:midvalvalselector}{MidVal}, \hyperlink{minval:minvalvalselector}{MinVal}
  \item \hyperlink{bestfit:bestfitvalselector}{BestFit}, \hyperlink{costregularvalselector:costregularvalselectorvalselector}{CostRegularValSelector}, \hyperlink{fcostregularvalselector:fcostregularvalselectorvalselector}{FCostRegularValSelector}, \hyperlink{randomintvalselector:randomintvalselectorvalselector}{RandomIntValSelector}, %\hyperlink{mcrvalselector:mcrvalselectorvalselector}{MCRValSelector}, 
  \end{itemize}
\end{notedef}
\item implementing interface \texttt{ValSelector<SetVar>}:
  \begin{notedef}\tt
\hyperlink{minenv:minenvvalselector}{MinEnv}, \hyperlink{randomsetvalselector:randomsetvalselectorvalselector}{RandomSetValSelector}
\end{notedef}
\end{itemize}


\subsection{Why is it important to define a search strategy ?}\label{solver:whyisitimportanttodefineasearchstrategy}\hypertarget{solver:whyisitimportanttodefineasearchstrategy}{}

%At a In a partial instantiation, when a fix point has been reached, the Solver needs to take a decision to resume the search. The way decisions are chosen has a \textbf{real impact on the resolution step efficient}. 
\begin{note}
\emph{The search strategy should not be under-estimatimated!!}
A well-suited search strategy can reduce: the execution time, the number of expanded nodes, the number of backtracks.
\end{note}
Let see that small example:
\begin{lstlisting}
	Model m = new CPModel();
        int n = 1000;
        IntegerVariable var = Choco.makeIntVar("var", 0, 2);
        IntegerVariable[] bi = Choco.makeBooleanVarArray("b", n);
        m.addConstraint(Choco.eq(var, Choco.sum(bi)));

        Solver badStrat = new CPSolver();
        badStrat.read(m);
        badStrat.addGoal(
                new AssignVar(
                        new MinDomain(badStrat), 
                        new IncreasingDomain()
                ));
        badStrat.solve();
        badStrat.printRuntimeStatistics();

        Solver goodStrat = new CPSolver();
        goodStrat.read(m);
        goodStrat.addGoal(
                new AssignVar(
                        new MinDomain(goodStrat, goodStrat.getVar(new IntegerVariable[]{var})), 
                        new IncreasingDomain()
                ));
        goodStrat.solve();
        goodStrat.printRuntimeStatistics();
\end{lstlisting}

This model ensures that $var = b_{0} + b_{1} + \ldots + b_{1000}$ where $var$ is an integer variable with a small domain $[0,2]$ and $b_{i}$ are binary variables. No deduction arose from the propagation here, so a fix point is reached at the beginning of the search. A branching decision has to be taken, by selecting a variable and the first value to assign to it. Using the first strategy, the solver will find a solution after creating 1001 nodes: it iterates over all the variables, starting by assigning the 1000 binary variables $b_i$ (according to the \texttt{MinDomain} variable selector) to $0$ (according to the \texttt{IncreasingDomain} value iterator), variable $var$ is fixed to $0$ at the very last propagation. The second strategy finds the same solution with only two nodes: after branching first on $var=0$, propagation immediately fixes all the binary variables to $0$. 

\subsection{Restarts}\label{solver:restarts}\hypertarget{solver:restarts}{}

Restart means stopping the current tree search, then starting a new tree search from the root node.
Restarting makes sense only when coupled with randomized dynamic branching strategies ensuring that the same enumeration tree is not constructed twice. The branching strategies based on the past experience of the search, such as \texttt{DomOverWDegBranching}, \texttt{DomOverWDegBinBranching} and \texttt{ImpactBasedBranching}, are more accurate in combination with a restart approach.

Unless the number of allowed restarts is limited, a tree search with restarts is not complete anymore. It is a good strategy, though, when optimizing an NP-hard problem in a limited time.


Restarts can be set using the following API available on the \texttt{Solver}:
\begin{lstlisting}
setGeometricRestart(int base, double grow);
setGeometricRestart(int base, double grow, int restartLimit);
\end{lstlisting}
It performs a search with restarts controlled by the number of backtracks. 
Parameter \texttt{base} indicates the maximal number of backtracks allowed in the first search tree. Once this limit is reached, a restart occurs and the search continues until \texttt{base}*\texttt{grow} backtracks are done, and so on. After each restart, the limit number of backtracks is increased by the geometric factor \texttt{grow}. 
\texttt{restartLimit} states the maximum number of restarts.
\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	s.setGeometricRestart(14, 1.5d);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	s.launch();
\end{lstlisting}

The Luby's restart policy is an alternative to the geometric restart policy, and can be defined 
using the following API available on the \texttt{Solver}:
\begin{lstlisting}
setLubyRestart(int base);
setLubyRestart(int base, int grow);
setLubyRestart(int base, int grow, int restartLimit);
\end{lstlisting}
It performs a search with restarts controlled by the number of backtracks. 
The maximum number of backtracks allowed at a given restart iteration is given by \texttt{base} multiplied by the Las Vegas coefficient at this iteration. 
The sequence of these coefficients is defined recursively on its prefix subsequences: starting from the first prefix $1$, the $(k+1)$-th prefix is the $k$-th prefix repeated \texttt{grow} times and immediately followed by coefficient \texttt{grow}$^k$.
\begin{itemize}
	\item the first coefficients for \texttt{grow}=2 : [1, 1, 2, 1, 1, 2, 4, 1, 1, 2, 1, 1, 2, 4, 8, 1,...]
	\item the first coefficients for \texttt{grow}=3 : [1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 3, 9,...]
\end{itemize}

\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	s.setLubyRestart(50, 2, 100);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	s.launch();
\end{lstlisting}

\section{Limiting Search Space}\label{solver:limitingsearchspace}\hypertarget{solver:limitingsearchspace}{}
The \texttt{Solver} class provides ways to limit the tree search controlled by different criteria.
%Limits may be imposed on the search algorithm to avoid spending too much time in the exploration. 
These limits have to be specified before the resolution. They are updated and checked each time a new node is created. 
 Once a limit is reached, the search stops even if no solution is found.
\begin{description}
\item[time limit:] concerns the elapsed time from the beginning of the search (i.e. from the call to a resolution method).
A time limit is set using the \texttt{Solver} API \mylst{setTimeLimit(int timeLimit)}, where \textit{timeLimit} is in milliseconds. 
\mylst{getTimeCount()} returns the total solving time. 
\item[node limit:] concerns the number of opened nodes.
A node limit is set using the \texttt{Solver} API \mylst{setNodeLimit(int nodeLimit)}.
\mylst{getNodeCount()} returns the total number of explored nodes.
\item[backtrack limit:] concerns the number of performed backtracks. 
A backtrack limit is set using the \texttt{Solver} API \mylst{setBackTrackLimit(int backtrackLimit)}.
\mylst{getBackTrackCount()} return the total number of backtracks.
\item[fail limit:] concerns the number of contradiction encountered.
A fail limit is set using the \texttt{Solver} API \mylst{setFailLimit(int failLimit)}.
\mylst{getFailCount()} returns the total number of failures.
By default, the failure count is recorded, one should call \mylst{monitorFailLimit(true)} to activate it.
\end{description}
\todo{Define all these notions more precisely and add an example.}

\section{Logging the search}\label{solver:logs}\hypertarget{solver:logs}{}
A logging class is available to produce trace statements throughout search: \mylst{ChocoLogging}. 

\subsection{Architecture }\label{solver:logarchitecture}\hypertarget{solver:logarchitecture}{}

Choco logging system is based on the \mylst{java.util.logging} package and located in the package \mylst{common.logging}.
Most Choco abstract classes or interfaces propose a static field \mylst{LOGGER}.
The following figures present the architecture of the logging system with the default verbosity.

\insertGraphique{.7\linewidth}{media/logger-default.png}{Logger Tree with the default verbosity}

The shape of the node depicts the type of logger:
\begin{itemize}
	\item The \emph{house} loggers represent private loggers. Do not use these loggers directly because their level are low and all messages would always be displayed.
	\item The \emph{octagon} loggers represent critical loggers. These loggers are provided in the variables, constraints and search classes and could have a huge impact on the global performance.
	\item The \emph{box} loggers are provided for dev and users.
\end{itemize}
The color of the node gives its logging level with DEFAULT verbosity:
\texttt{Level.FINEST} (\textcolor{yellow}{gold}),
\texttt{Level.INFO} (\textcolor{orange}{orange}),
\texttt{Level.WARNING} (\textcolor{red}{red}).

\subsection{Verbosities and messages}\label{solver:verbosityandmessages}\hypertarget{solver:verbosityandmessages}{}

The verbosity level of the solver can be set by the following static method :

\begin{lstlisting}
	// Before the resolution
	ChocoLogging.toVerbose();
	//... resolution declaration
	solver.solve();
	// And after the resolution
	ChocoLogging.flushLogs();
\end{lstlisting}


The following table summarizes the verbosities available in choco: 
\begin{itemize}
	\item \textbf{OFF -- level 0:} Disable logging.	 

	\vspace{0.2cm} 
	\textit{Usage} :  \mylst{ChocoLogging.setVerbosity(Verbosity.OFF)}
	
	\item \textbf{SILENT -- level 1:} Display only severe messages.
	
	\vspace{0.2cm} 
	\textit{Usage} : 
		\begin{itemize}
		\item \mylst{ChocoLogging.toSilent()}
		\item \mylst{ChocoLogging.setVerbosity(Verbosity.SILENT)}
		\end{itemize}
	
	\item \textbf{DEFAULT -- level 2:} Display informations on final search state.
		\begin{itemize}
			\item ON START
				\lstset{language={sh},columns=fixed}
\begin{lstlisting}
 ** CHOCO : Constraint Programming Solver
 ** CHOCO v2.1.1 (April, 2009), Copyleft (c) 1999-2010
 \end{lstlisting}
			\item ON COMPLETE SEARCH:
				\begin{lstlisting}
- Search completed -
 [Maximize		: {0},]
 [Minimize		: {1},]
  Solutions		: {2},
  Times (ms)	: {3},
  Nodes			: {4},
  Backtracks	: {5},
  Restarts		: {6}.
  \end{lstlisting}
	brackets [\textit{line}] indicate \textit{line} is optional,\\
 	\texttt{Maximize} --resp. \texttt{Minimize}-- indicates the best known value before exiting of the objective value in \textit{maximize()} --resp. \textit{minimize()}-- strategy.

			\item ON COMPLETE SEARCH WITHOUT SOLUTIONS :
				\begin{lstlisting}
- Search completed - No solutions
 [Maximize		: {0},]
 [Minimize		: {1},]
  Solutions		: {2},
  Times (ms)	: {3},
  Nodes			: {4},
  Backtracks	: {5},
  Restarts		: {6}.
\end{lstlisting}
	brackets [\textit{line}] indicate \textit{line} is optional,\\
 	\texttt{Maximize} --resp. \texttt{Minimize}-- indicates the best known value before exiting of the objective value in \textit{maximize()} --resp. \textit{minimize()}-- strategy.

			\item ON INCOMPLETE SEARCH:
				\begin{lstlisting}
- Search incompleted - Exiting on limit reached
  Limit			: {0},
 [Maximize		: {1},]
 [Minimize		: {2},]
  Solutions		: {3},
  Times (ms)	: {4},
  Nodes			: {5},
  Backtracks	: {6},
  Restarts		: {7}.
  
  \end{lstlisting}
	brackets [\textit{line}] indicate \textit{line} is optional,\\
 	\texttt{Maximize} --resp. \texttt{Minimize}-- indicates the best known value before exiting of the objective value in \textit{maximize()} --resp. \textit{minimize()}-- strategy.
		\end{itemize}			

	\textit{Usage} : 
		\begin{itemize}
		\item \mylst{ChocoLogging.toDefault()}
		\item \mylst{ChocoLogging.setVerbosity(Verbosity.DEFAULT)}
		\end{itemize}

	\item \textbf{VERBOSE -- level 3:} Display informations on search state.
		\begin{itemize}
			\item EVERY X (default=1000) NODES:
			\begin{lstlisting}
- Partial search - [Objective : {0}, ]{1} solutions, {2} Time (ms), {3} Nodes, {4} Backtracks, {5} Restarts.
			\end{lstlisting}
			\texttt{Objective} indicates the best known value.

			\item ON RESTART : 
			\begin{lstlisting}
- Restarting search - {0} Restarts.
			\end{lstlisting}
		\end{itemize}
		
		\textit{Usage} : 
		\begin{itemize}
		\item \mylst{ChocoLogging.toVerbose()}
		\item \mylst{ChocoLogging.setVerbosity(Verbosity.VERBOSE)}
		\end{itemize}

	\item \textbf{SOLUTION -- level 4:} display all solutions.
		\begin{itemize}
			\item AT EACH SOLUTION:
			\begin{lstlisting}
- Solution #{0} found. [Objective: {0}, ]{1} Solutions, {2} Time (ms), {3} Nodes, {4} Backtracks, {5} Restarts.
  X_1:v1, x_2:v2...
			\end{lstlisting}
		\end{itemize}
		
		\textit{Usage} : 
		\begin{itemize}
		\item \mylst{ChocoLogging.toSolution()}
		\item \mylst{ChocoLogging.setVerbosity(Verbosity.SOLUTION)}
		\end{itemize}

	\item \textbf{SEARCH -- level 5:} Display the search tree.
		\begin{itemize}
			\item AT EACH NODE, ON DOWN BRANCH:
			\begin{lstlisting}
...[w] down branch X==v branch b
			\end{lstlisting}
where \texttt{w} is the current world index, \texttt{X} the branching variable, \texttt{v} the branching value and \texttt{b} the branch index. This message can be adapted on variable type and search strategy.

			\item AT EACH NODE, ON UP BRANCH:
			\begin{lstlisting}
...[w] up branch X==v branch b
			\end{lstlisting}
where \texttt{w} is the current world index, \texttt{X} the branching variable, \texttt{v} the branching value and \texttt{b} the branch index. 
		\end{itemize}
		
		\textit{Usage} : 
		\begin{itemize}
		\item \mylst{ChocoLogging.toSearch()}
		\item \mylst{ChocoLogging.setVerbosity(Verbosity.SEARCH)}
		\end{itemize}

	\item \textbf{FINEST -- level 6:} display all logs.
	
	\vspace{0.2cm} 
	\textit{Usage} :  \mylst{ChocoLogging.setVerbosity(Verbosity.FINEST)}

\end{itemize}

More precisely, if the verbosity level is greater than DEFAULT, then the verbosity levels of the model and of the solver are increased to INFO, and the verbosity levels of the search and of the branching are slightly modified to display the solution(s) and search messages.

\subsection{Basic settings}\label{solver:logbasicsettings}\hypertarget{solver:logbasicsettings}{}

Note that in the case of a verbosity greater or equals to \texttt{toVerbose()}, the regular search information step is set to 1000, by default. You can change this value, using:
\begin{lstlisting}
  ChocoLogging.setEveryXNodes(20000);
\end{lstlisting}
 

Note that in the case of verbosity \texttt{toSearch()}, trace statements are printed up to a maximal depth in the search tree. The default value is set to 25, but you can change the value of this threshold, say to 10, with the following setter method:
\begin{lstlisting}
  ChocoLogging.setLoggingMaxDepth(10);
\end{lstlisting}


\section{Clean a Solver}\label{solver:clean}\hypertarget{solver:clean}{}

Although it is simple and secure to create new instance of \mylst{Solver}, sometimes it  is more obvious and efficient to reuse a \mylst{Solver}. 
It is recommended to reuse instance of \mylst{Solver} when a problem is being solved more than once without deep modifications between two resolutions:
\begin{itemize}
\item a problem is being resolved with different search strategies,
\item a problem is being modified (by adding or removing constraints) through multiple resolutions.
\end{itemize}

\begin{note}
Reusing a \mylst{Solver} must be prepared and well thought out. A backup of the initial state of the \mylst{Solver} may be necessary to recover initial domains and constraints internal structures. In the case where new constraints are created and added, this must be done manipulating \mylst{Solver} objects (SConstraint for example). So, this required knowledge in advanced uses of \mylst{Solver}.
\end{note}

What are the methods to clean up a Solver ?
\begin{itemize}
\item \underline{reset the search strategy :} this is done by calling \mylst{resetSearchStrategy()} on a \mylst{CPSolver}.
A call to this method clears the defined branching strategies (safely removes previous ones) and sets the current search strategy to \mylst{null}.
User's defined branching strategies must be defined again.
User's defined limits will be reset for the next search.

\item \underline{cancel restarts :} this is done by calling \mylst{cancelRestarts(Solver solver)} on \mylst{RestartFactory}.
Sets the restarts parameters to the default ones. This must be done if a restart strategy has been declared.

\end{itemize}

\subsection{What about simply calling \mylst{solver.clear()}?}

A call to \mylst{solver.clear()} will reset every internal structures of a \mylst{Solver}: it clears the variable list, the constraint list, the environment, the propagation engine, the model read, etc.
This set the solver in the same state as it was just after its creation.

\subsection{Things to know about \mylst{Solver} reusability}

There are few things to know:
\begin{itemize}
\item a variable cannot be removed from a \mylst{Solver},
\item a statically posted constraint (added using \mylst{solver.postCut(SConstraint c)}) can be removed \textit{at any time} using \mylst{void eraseConstraint(SConstraint c)},
\item a dynamically posted constraint (added using \mylst{solver.post(SConstraint c)}) can be removed \textit{at root node} using \mylst{void eraseConstraint(SConstraint c)}.
\end{itemize}


%\subsection{Optimization}\label{solver:optimization}\hypertarget{solver:optimization}{}
%\todo{to introduce}
%\begin{lstlisting}
%  Model m = new CPModel();
%  IntegerVariable obj1 = makeEnumIntVar("obj1", 0, 7);
%  IntegerVariable obj2 = makeEnumIntVar("obj1", 0, 5);
%  IntegerVariable obj3 = makeEnumIntVar("obj1", 0, 3);
%  IntegerVariable cost = makeBoundIntVar("cout", 0, 1000000);
%  int capacity = 34;
%  int[] volumes = new int[]{7, 5, 3};
%  int[] energy = new int[]{6, 4, 2};
%  // capacity constraint
%  m.addConstraint(leq(scalar(volumes, new IntegerVariable[]{obj1, obj2, obj3}), capacity));
%	
%  // objective function
%  m.addConstraint(eq(scalar(energy, new IntegerVariable[]{obj1, obj2, obj3}), cost));
%  
%  Solver s = new CPSolver();
%  s.read(m);
%  
%  s.maximize(s.getVar(cost), false);
%\end{lstlisting}
